<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>åƒç´ å†œåœºï¼šè‡ªåŠ¨åˆæˆç”°åœ°</title>
  <style>
    :root {
      --bg: linear-gradient(135deg, #dfeee5 0%, #cde0da 50%, #d9e9f0 100%);
      --card: #f6fbff;
      --card-strong: #eef5fa;
      --border: #d2dee7;
      --text: #1f2b38;
      --muted: #6b7a8a;
      --accent: #62b38a;
      --accent-2: #7a9bd0;
      --warn: #f6b34e;
      --danger: #f26d6d;
      --success: #64c58a;
      --shadow: 0 10px 30px rgba(0,0,0,0.08);
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: "Segoe UI", "Microsoft YaHei", sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; }
    h3 { margin: 0 0 6px; font-size: 15px; }
    .layout { display: flex; gap: 16px; padding: 16px; }
    .sidebar { display: flex; flex-direction: column; gap: 12px; }
    .left { width: 220px; }
    .right { width: 300px; }
    .main { flex: 1; min-width: 620px; display: flex; flex-direction: column; gap: 12px; }
    .card, .info-card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 12px 14px; box-shadow: var(--shadow); }
    .info-card strong.title { font-size: 14px; display: block; margin-bottom: 6px; }
    .title::before { content: "ğŸ’¡ "; }
    .farm-card-title::before { content: "ğŸŒ¾ "; }
    .farm-deco-title::before { content: "ğŸ  "; }
    .row { display: flex; gap: 12px; align-items: stretch; }
    .grow { flex: 1; }
    .center { display: flex; justify-content: center; align-items: center; }
    .muted { color: var(--muted); font-size: 12px; }
    .value { font-weight: 700; color: var(--accent); }
    .btn { padding: 6px 10px; border-radius: 10px; border: 1px solid var(--border); background: white; cursor: pointer; font-size: 13px; transition: 0.15s all ease; color: var(--text); }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 4px 10px rgba(0,0,0,0.08); }
    .btn.primary { background: var(--accent); color: white; border-color: #58a27d; }
    .btn.secondary { background: var(--accent-2); color: white; border-color: #6a8bbf; }
    .btn.warn { background: var(--warn); color: #5b3b04; border-color: #e4a03f; }
    .btn.danger { background: var(--danger); color: white; border-color: #e55b5b; }
    .btn.small { padding: 5px 8px; font-size: 12px; }
    .btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; box-shadow: none; }
    select, input[type="text"] { width: 100%; padding: 6px 8px; border-radius: 10px; border: 1px solid var(--border); background: white; font-size: 13px; color: var(--text); }
    ul { margin: 4px 0 0; padding-left: 16px; }
    canvas { background: #f9f4f1; border-radius: 18px; box-shadow: var(--shadow); border: 10px solid #b0794b; }
    #gameBoard { width: 540px; height: 540px; }
    .canvas-wrap { display: flex; justify-content: center; align-items: center; }
    .tag { display: inline-block; padding: 2px 6px; border-radius: 8px; font-size: 12px; background: var(--card-strong); border: 1px solid var(--border); margin-right: 4px; }
    .tag.success { background: #e6f8ee; color: #2c8f5f; border-color: #b9e4cc; }
    .tag.danger { background: #fdeaea; color: #c74747; border-color: #f3c0c0; }
    .list-line { display: flex; justify-content: space-between; align-items: center; margin: 4px 0; font-size: 13px; }
    .progress { width: 100%; height: 8px; background: #e6eef4; border-radius: 10px; overflow: hidden; }
    .progress span { display: block; height: 100%; background: var(--accent); }
    #toast { position: fixed; right: 22px; bottom: 22px; padding: 10px 14px; background: rgba(47,62,78,0.92); color: white; border-radius: 10px; opacity: 0; pointer-events: none; transform: translateY(10px); transition: 0.25s ease; box-shadow: var(--shadow); font-size: 13px; }
    #toast.show { opacity: 1; transform: translateY(0); }
    .flex-wrap { display: flex; flex-wrap: wrap; gap: 6px; }
    .pill { padding: 4px 8px; border-radius: 10px; background: #eef3f8; border: 1px solid #d6e1eb; font-size: 12px; }
    .highlight { color: var(--accent); font-weight: 700; }
    .mode-btns .btn { margin-right: 6px; }
    .full { width: 100%; }
    .market-item-card { border: 1px dashed var(--border); border-radius: 12px; padding: 10px 12px; background: #fdfdfc; margin: 6px 0; box-shadow: inset 0 1px 0 rgba(255,255,255,0.6); }
    .market-title { font-weight: 700; margin-bottom: 4px; color: var(--text); }
    .market-meta { display: flex; justify-content: space-between; color: var(--muted); font-size: 12px; margin-bottom: 6px; }
    .market-actions .btn { width: 100%; }
    .processing-card { padding: 10px; border: 1px solid var(--border); border-radius: 12px; background: #f6fbff; box-shadow: var(--shadow); margin-bottom: 8px; }
    .processing-title { font-weight: 700; color: var(--text); margin-bottom: 4px; }
    .processing-eta { color: var(--muted); font-size: 12px; margin-bottom: 6px; }
    .recipe-card { border: 1px solid var(--border); border-radius: 12px; padding: 10px 12px; background: #fff; margin-bottom: 8px; }
    .recipe-card.active { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(98,179,138,0.2); }
    .recipe-head { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
    .recipe-io { font-size: 12px; margin-bottom: 4px; }
    .recipe-gain { color: var(--accent); font-size: 12px; margin-bottom: 6px; }
    .recipe-footer .btn { width: 100%; }
    .order-card { border: 1px solid var(--border); border-radius: 10px; padding: 10px 12px; background: #fffef9; box-shadow: 0 2px 6px rgba(0,0,0,0.06); margin-bottom: 8px; }
    .order-head { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }

    /* å³ä¾§æ ç¾åŒ– + æ ‡ç­¾é¡µå¸ƒå±€ */
    .sidebar.right {
      gap: 10px;
      max-height: calc(100vh - 32px);
      overflow-y: auto;
      padding-right: 4px;
    }

    .sidebar.right .info-card {
      padding: 10px 12px;
      margin-bottom: 6px;
    }

    .right-tabs-header {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .right-tabs-header .tab-btn {
      flex: 1;
      text-align: center;
      border-radius: 999px;
      background: #eef3f8;
      border: 1px solid var(--border);
      font-size: 12px;
      padding: 6px 8px;
      white-space: nowrap;
    }

    .right-tabs-header .tab-btn.active {
      background: var(--accent);
      color: #fff;
      border-color: #58a27d;
      box-shadow: 0 4px 10px rgba(0,0,0,0.12);
    }

    .tab-panel {
      display: none;
    }

    .tab-panel.active {
      display: block;
    }

    /* ===== æ–°å¢ï¼šå†œåœºå·¦å³ä¾§æ å¸ƒå±€ä¸å¡ç‰‡ ===== */
    .farm-layout {
      display: flex;
      align-items: stretch;
      justify-content: center;
      gap: 16px;
      row-gap: 12px;
      max-width: 1280px;
      margin: 0 auto;
      width: 100%;
      flex-wrap: wrap;
    }
    .farm-sidebar {
      width: 220px;
      flex: 0 1 220px;
      min-width: 160px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .farm-layout .canvas-wrap {
      flex: 1 1 540px;
      display: flex;
      justify-content: center;
      align-items: center;
      min-width: 540px;
    }
    .farm-deco-card,
    .farm-stats-card,
    .farm-actions-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      box-shadow: var(--shadow);
      color: var(--text);
    }
    .farm-deco-card {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .farm-deco-icon {
      width: 56px;
      height: 56px;
      border-radius: 14px;
      background: var(--card-strong);
      border: 1px solid var(--border);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.6);
    }
    .farm-deco-icon svg {
      width: 36px;
      height: 36px;
    }
    .farm-card-title,
    .farm-deco-title {
      font-weight: 700;
      margin-bottom: 6px;
    }
    .farm-deco-text {
      flex: 1;
      min-width: 0;
    }
    .farm-stats-card {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .farm-stats-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--text);
    }
    .farm-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(98,179,138,0.15);
      flex-shrink: 0;
    }
    .farm-action-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .farm-action-btn {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      box-shadow: 0 6px 16px rgba(98,179,138,0.18);
      transition: transform 0.15s ease, filter 0.15s ease, box-shadow 0.15s ease;
    }
    .farm-action-btn:hover {
      transform: translateY(-1px) scale(1.01);
      filter: brightness(1.03);
      box-shadow: 0 8px 18px rgba(98,179,138,0.25);
    }
    .farm-action-btn:active {
      transform: translateY(0);
      filter: brightness(0.98);
    }
    @media (max-width: 1200px) {
      .farm-layout {
        flex-wrap: wrap;
      }
      .farm-layout .canvas-wrap {
        order: 1;
        flex: 1 1 100%;
        min-width: 320px;
      }
      .farm-sidebar {
        order: 2;
        width: 100%;
        flex: 1 1 160px;
      }
    }

    /* æ”¶è·å³æ—¶å†³ç­–å°é¢æ¿ */
    #harvestDecision {
      position: fixed;
      left: 50%;
      bottom: 96px;
      transform: translateX(-50%);
      min-width: 260px;
      max-width: 360px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      box-shadow: var(--shadow);
      padding: 10px 12px;
      z-index: 50;
    }

    #harvestDecision.hidden {
      display: none;
    }

    #harvestDecisionTitle {
      font-size: 14px;
      font-weight: 700;
      margin-bottom: 4px;
    }

    #harvestDecisionText {
      font-size: 12px;
      color: var(--muted);
    }

    #harvestDecisionButtons {
      margin-top: 8px;
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }
  </style>
</head>
<body>
  <div class="layout">
    <div class="sidebar left">
      <div class="info-card">
        <strong class="title">è´¦å·</strong>
        <div style="display:flex; gap:6px; margin-bottom:6px;">
          <select id="accountSelect"></select>
          <input id="accountName" type="text" placeholder="æ–°å»ºè´¦å·å" />
        </div>
        <div class="flex-wrap">
          <button class="btn small primary" onclick="createAccount()">åˆ›å»º/åˆ‡æ¢</button>
          <button class="btn small" onclick="saveGame()">å­˜æ¡£</button>
          <button class="btn small" onclick="loadGame()">è¯»æ¡£</button>
          <button class="btn small danger" onclick="deleteAccount()">åˆ é™¤</button>
        </div>
      </div>
      <div class="info-card">
        <strong class="title">æ¸¸æˆæ—¥ / æ—¶é—´</strong>
        <div id="timeInfo" class="value">ç¬¬1å¤© 00:00</div>
      </div>
      <div class="info-card" id="weatherCard">
        <strong class="title">å¤©æ°”</strong>
        <div id="weatherName" class="value">æ™´å¤©</div>
        <div id="weatherDesc" class="muted">é˜³å…‰æ˜åªšï¼Œä½œç‰©æ­£å¸¸ç”Ÿé•¿ã€‚</div>
      </div>
      <div class="info-card" id="seasonCard">
        <strong class="title">å­£èŠ‚</strong>
        <div id="seasonName" class="value">æ˜¥å­£</div>
        <div id="seasonDesc" class="muted">æ˜¥å›å¤§åœ°ï¼Œä½œç‰©ç”Ÿé•¿ç•¥å¿«ï¼Œä»·æ ¼åŸºæœ¬æ­£å¸¸ã€‚</div>
      </div>
      <div class="info-card">
        <strong class="title">é‡‘å¸</strong>
        <div class="value" id="goldDisplay">50</div>
      </div>
      <div class="info-card" id="reputationCard">
        <strong class="title">å£°æœ›</strong>
        <div id="reputationInfo">å£°æœ›å€¼0ï¼Œ0çº§</div>
        <div id="reputationPerks" class="muted" style="margin-top:4px;">å·²è·å¾—å¤©èµ‹ï¼šæ— </div>

        <div class="muted" style="margin-top:4px;">å£°æœ›è¶Šé«˜ï¼Œå¯è§£é”æ›´å¤šæ–¹å­å’Œè®¢å•ä½</div>
      </div>
      <div class="info-card">
        <strong class="title">æ¯æ—¥ä»»åŠ¡</strong>
        <div id="dailyQuest">ç­‰å¾…åˆ·æ–°ä»»åŠ¡</div>
      </div>
      <div class="info-card">
        <strong class="title">é™æ—¶æ´»åŠ¨</strong>
        <div class="muted">æš‚æœªå¼€æ”¾ï¼Œæ•¬è¯·æœŸå¾…</div>
      </div>
      <div class="info-card">
        <strong class="title">æ’è¡Œæ¦œ</strong>
        <div class="muted">å£°æœ›è¶Šé«˜+è®¢å•è¶Šå¤šå¾—åˆ†è¶Šé«˜</div>
      </div>
    </div>

    <div class="main">
      <div class="row">
        <div class="info-card grow">
          <strong class="title">æç¤º</strong>
          <div id="tipMessage" class="muted">å…ˆè§£é”å‡ å—åœŸåœ°å†å¼€å§‹ç§æ¤å§ã€‚</div>
        </div>
        <div class="info-card grow">
          <strong class="title">åœŸåœ°ä¿¡æ¯</strong>
          <div id="landInfo" class="muted">æœªé€‰æ‹©åœ°å—ã€‚</div>
        </div>
        <div class="info-card" style="width: 220px;">
          <strong class="title">æ“ä½œæ¨¡å¼</strong>
          <div class="mode-btns">
            <button class="btn small" id="modeNormal" onclick="setMode('normal')">æ­£å¸¸</button>
            <button class="btn small" id="modeSwap" onclick="setMode('swap')">äº¤æ¢</button>
          </div>
          <div class="muted" style="margin-top:6px;">ä¸‰å—åŒçº§å·²è§£é”åœŸåœ°ä¼šè‡ªåŠ¨åˆæˆå‡çº§ï¼Œæ‰‹åŠ¨åˆæˆåŠŸèƒ½å·²å…³é—­ã€‚</div>
        </div>
      </div>

      <div class="farm-layout">
        <aside class="farm-sidebar farm-sidebar-left">
          <div class="farm-deco-card">
            <div class="farm-deco-icon" aria-hidden="true">
              <svg viewBox="0 0 64 64" role="img" focusable="false">
                <path d="M12 30.5 32 15l20 15.5" fill="none" stroke="#5f9f78" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/>
                <rect x="18" y="30" width="28" height="20" rx="4" fill="#cde6d5" stroke="#6fa783" stroke-width="3"/>
                <rect x="30" y="36" width="8" height="14" rx="2" fill="#f6fbff" stroke="#6fa783" stroke-width="2"/>
                <path d="M22 30V22c0-2 1.5-3 3.5-3h13c2 0 3.5 1 3.5 3v8" fill="#f5d6b1" stroke="#c49a6c" stroke-width="3"/>
              </svg>
            </div>
            <div class="farm-deco-text">
              <div class="farm-deco-title">å†œèˆ & ä»“åº“</div>
              <div class="muted">å®‰é™çš„å°å†œèˆï¼Œå­˜æ”¾ä½ çš„æ”¶è·ã€‚</div>
            </div>
          </div>
          <div class="farm-stats-card">
            <div class="farm-card-title">å†œåœºæ¦‚å†µ</div>
            <div class="farm-stats-row">
              <span class="farm-dot"></span>
              <span>å·²æ’­ç§åœ°å—ï¼š<span id="farmStatPlanted">0 / 0</span></span>
            </div>
            <div class="farm-stats-row">
              <span class="farm-dot"></span>
              <span>æˆç†Ÿåœ°å—ï¼š<span id="farmStatReady">0 å—</span></span>
            </div>
            <div class="farm-stats-row">
              <span class="farm-dot"></span>
              <span>å…¨å±€åŠ æˆï¼š<span id="farmStatBonus">+0%</span></span>
            </div>
          </div>
        </aside>

        <div class="canvas-wrap">
          <canvas id="gameBoard" width="540" height="540"></canvas>
        </div>

        <aside class="farm-sidebar farm-sidebar-right">
          <div class="farm-deco-card">
            <div class="farm-deco-icon" aria-hidden="true">
              <svg viewBox="0 0 64 64" role="img" focusable="false">
                <path d="M8 46c6-6 14-10 24-10s18 4 24 10" fill="#d7e7de"/>
                <path d="M32 12v32" stroke="#7aa9d4" stroke-width="3" stroke-linecap="round"/>
                <path d="M32 20 18 26l14 6 14-6-14-6Z" fill="#9fc5e5" stroke="#6a94bf" stroke-width="2" stroke-linejoin="round"/>
                <rect x="28" y="44" width="8" height="8" rx="2" fill="#f6fbff" stroke="#6a94bf" stroke-width="2"/>
              </svg>
            </div>
            <div class="farm-deco-text">
              <div class="farm-deco-title">é£è½¦ä¸˜</div>
              <div class="muted">é£å¹è¿‡ï¼Œåº„ç¨¼é•¿å¾—æ›´å¿«ã€‚</div>
            </div>
          </div>
          <div class="farm-actions-card">
            <div class="farm-card-title">å¿«æ·æ“ä½œ</div>
            <div class="farm-action-list">
              <button class="farm-action-btn btn primary" onclick="handleQuickHarvest()">ä¸€é”®æ”¶è·</button>
              <button class="farm-action-btn btn primary" onclick="handleQuickPlant()">ä¸€é”®æ’­ç§</button>
              <button class="farm-action-btn btn primary" onclick="handleQuickFertilize()">ä¸€é”®æ–½è‚¥</button>
              <button class="farm-action-btn btn secondary" onclick="handleToggleDisplayMode()">åˆ‡æ¢æ˜¾ç¤ºæ¨¡å¼</button>
            </div>
          </div>
        </aside>
      </div>

      <div class="row">
        <div class="info-card grow">
          <strong class="title">ä¸»çº¿ç›®æ ‡</strong>
          <div id="mainQuest" class="muted">æ‰“é€ ä½ çš„ç¬¬ä¸€ç‰‡é»„é‡‘ç”°ã€‚</div>
        </div>
        <div class="info-card grow">
          <strong class="title">æˆå°±è¿›åº¦</strong>
          <div id="achievements" class="muted">å·²å®Œæˆ 0 / 3</div>
        </div>
        <div class="info-card grow">
          <strong class="title">AI å¯¹è¯</strong>
          <div class="muted">// TODOï¼šåç»­åŠ å…¥ AI å¯¹è¯</div>
        </div>
      </div>
    </div>

    <div class="sidebar right">
      <!-- æ ‡ç­¾å¤´ -->
      <div class="info-card">
        <div class="right-tabs-header">
          <button class="btn small tab-btn active" data-tab="plant">ç§æ¤</button>
          <button class="btn small tab-btn" data-tab="trade">äº¤æ˜“</button>
          <button class="btn small tab-btn" data-tab="market">å¸‚åœº</button>
          <button class="btn small tab-btn" data-tab="process">åŠ å·¥</button>
          <button class="btn small tab-btn" data-tab="achievement">æˆå°±</button>
        </div>
      </div>

      <!-- ç§æ¤æ ‡ç­¾é¡µ -->
      <div class="tab-panel active" data-tab="plant">
        <div class="info-card">
          <strong class="title">ç§æ¤é€‰æ‹©</strong>
          <select id="seedSelect"></select>
          <div class="muted" style="margin-top:6px;">åœ¨è§£é”åœ°å—ä¸Šç§æ¤å½“å‰é€‰æ‹©çš„ç§å­</div>
        </div>
        <div class="info-card">
          <strong class="title">èƒŒåŒ…</strong>
          <div id="inventoryList"></div>
        </div>
        <div class="info-card">
          <strong class="title">ä»“åº“</strong>
          <div id="storageRaw" class="muted">åŸæ–™ï¼šå°éº¦ x0 | ç‰ç±³ x0 | å—ç“œ x0 | èåœ x0 | è‰è“ x0</div>
          <div id="storageGoods" class="muted" style="margin-top:4px;">æˆå“ï¼šé¢åŒ… x0 | çˆ†ç±³èŠ± x0 | å—ç“œæ´¾ x0 | è…Œèåœ x0 | è‰è“é…± x0</div>
        </div>
        <div class="info-card">
          <strong class="title">å¢ç›Š / æ¸…ç†</strong>
          <div class="flex-wrap">
            <button class="btn small secondary" onclick="boostTile()">æ–½è‚¥ï¼ˆ+10%é€Ÿåº¦ï¼‰</button>
            <button class="btn small" onclick="cleanTile()">æ¸…ç†ï¼ˆç§»é™¤ä½œç‰©ï¼‰</button>
          </div>
          <div class="muted" style="margin-top:6px;">æ–½è‚¥ä½œç”¨äºå½“å‰é€‰ä¸­çš„åœ°å—ï¼ŒåŠ é€Ÿç”Ÿé•¿ï¼›æ¸…ç†ä¼šç§»é™¤å½“å‰ä½œç‰©ã€‚</div>
        </div>
      </div>

      <!-- äº¤æ˜“æ ‡ç­¾é¡µ -->
      <div class="tab-panel" data-tab="trade">
        <div class="info-card" id="shopCard">
          <strong class="title">å†œåœºå•†åº—</strong>
          <div id="shopList"></div>
        </div>
        <div class="info-card">
          <strong class="title">è®¢å•</strong>
          <div id="ordersList" class="muted">æš‚æ— è®¢å•</div>
        </div>
      </div>

      <!-- å¸‚åœºæ ‡ç­¾é¡µ -->
      <div class="tab-panel" data-tab="market">
        <div class="info-card" id="marketCard">
          <strong class="title">å†œäº§å“å¸‚åœº</strong>
          <div id="marketList" class="muted"></div>
          <div class="muted" style="margin-top:6px;">æç¤ºï¼šåœ¨å¸‚åœºå‡ºå”®ä¸ä¼šè·å¾—å£°æœ›ï¼Œå®Œæˆè®¢å•æ‰ä¼šæå‡å£°æœ›ã€‚</div>
        </div>
      </div>

      <!-- åŠ å·¥æ ‡ç­¾é¡µ -->
      <div class="tab-panel" data-tab="process">
        <div class="info-card">
          <strong class="title">åŠ å·¥è½¦é—´</strong>
          <div id="processingCapacityText" class="muted">åŠ å·¥ä½ï¼š0 / 1</div>
          <div id="processingStatus" class="muted" style="margin-top:4px;">ç©ºé—²ä¸­</div>
          <div id="processingBtns" style="margin-top:8px;"></div>
          <div id="processingUpgrade" style="margin-top:8px;"></div>
        </div>
        <div class="info-card">
          <div class="muted">æç¤ºï¼šå•†å“åŠ å·¥éœ€è¦æ—¶é—´ï¼Œæˆå“å¯äº¤ä»˜è®¢å•ï¼Œå£°æœ›åˆ° 2 çº§è§£é”å—ç“œæ´¾ã€‚</div>
        </div>
      </div>

      <!-- æˆå°±æ ‡ç­¾é¡µ -->
      <div class="tab-panel" data-tab="achievement">
        <div class="info-card">
          <strong class="title">æˆå°±</strong>
          <div id="achievementDetails" class="muted">æˆå°±ï¼š1 æ§½è§£é” / å®Œæˆé«˜çº§é…æ–¹ / å®Œæˆ 3 å¼ è®¢å•</div>
        </div>
      </div>
    </div>
  </div>

  <div id="harvestDecision" class="hidden">
    <div id="harvestDecisionTitle">æ”¶è·å†³ç­–</div>
    <div id="harvestDecisionText" class="muted"></div>
    <div id="harvestDecisionButtons">
      <button class="btn small primary" onclick="confirmHarvestDecision('sell')">ç›´æ¥å–æ‰</button>
      <button class="btn small" onclick="confirmHarvestDecision('store')">å…¥ä»“åŠ å·¥</button>
    </div>
  </div>

  <div id="toast"></div>

<script>
  // ========= æ•°æ®å®šä¹‰ =========
  const DAY_MINUTES = 24 * 60;
  const TIME_SPEED = 5; // æ¯ç§’ç°å®æ—¶é—´å¯¹åº”çš„æ¸¸æˆåˆ†é’Ÿæ•°ï¼Œå¯æ ¹æ®éœ€è¦è°ƒèŠ‚

  // ========= æ¯æ—¥å¤©æ°”ç³»ç»Ÿ =========
  const WEATHER_TYPES = [
    {
      id: 'sunny',
      name: 'æ™´å¤©',
      desc: 'é˜³å…‰æ˜åªšï¼Œä½œç‰©æ­£å¸¸ç”Ÿé•¿ã€‚',
      growFactor: 1.0
    },
    {
      id: 'cloudy',
      name: 'å¤šäº‘',
      desc: 'å…‰ç…§ç¨å¼±ï¼Œä½œç‰©ç”Ÿé•¿ç•¥æ…¢ã€‚',
      growFactor: 1.05
    },
    {
      id: 'rainy',
      name: 'å°é›¨',
      desc: 'é›¨æ°´å……è¶³ï¼Œä½œç‰©ç”Ÿé•¿ç¨å¿«ã€‚',
      growFactor: 0.9
    },
    {
      id: 'storm',
      name: 'æš´é›¨',
      desc: 'å¤©æ°”æ¶åŠ£ï¼Œä½†é›¨æ°´å……è¶³ï¼Œä½œç‰©ç”Ÿé•¿æ˜æ˜¾åŠ å¿«ã€‚',
      growFactor: 0.8
    }
  ];

  // weather: å½“å‰å¤©æ°”ä¸‹æ ‡ï¼Œä»¥åŠè®°å½•å¤©æ°”ç”Ÿæˆçš„æ¸¸æˆæ—¥
  let currentWeatherIndex = 0;
  let lastWeatherDay = 0;

  // ========= å­£èŠ‚ç³»ç»Ÿï¼ˆæ˜¥å¤ç§‹å†¬ï¼Œæ¯å­£ 21 å¤©ï¼‰ =========
  const SEASONS = [
    {
      id: 'spring',
      name: 'æ˜¥å­£',
      desc: 'æ˜¥å›å¤§åœ°ï¼Œä½œç‰©ç”Ÿé•¿ç•¥å¿«ï¼Œä»·æ ¼åŸºæœ¬æ­£å¸¸ã€‚',
      growFactor: 0.9,
      priceFactorRaw: 1.0,
      priceFactorGoods: 1.0
    },
    {
      id: 'summer',
      name: 'å¤å­£',
      desc: 'çƒˆæ—¥ç‚ç‚ï¼Œæˆå“éœ€æ±‚ä¸Šå‡ï¼Œå”®ä»·ç•¥é«˜ã€‚',
      growFactor: 1.0,
      priceFactorRaw: 1.0,
      priceFactorGoods: 1.10
    },
    {
      id: 'autumn',
      name: 'ç§‹å­£',
      desc: 'ä¸°æ”¶çš„å­£èŠ‚ï¼ŒåŸæ–™éœ€æ±‚å˜é«˜ã€‚',
      growFactor: 1.0,
      priceFactorRaw: 1.10,
      priceFactorGoods: 1.0
    },
    {
      id: 'winter',
      name: 'å†¬å­£',
      desc: 'å¯’é£å‡›å†½ï¼Œä½œç‰©ç”Ÿé•¿ç•¥æ…¢ï¼Œä½†ç²®é£Ÿæ•´ä½“æ›´å€¼é’±ã€‚',
      growFactor: 1.10,
      priceFactorRaw: 1.05,
      priceFactorGoods: 1.05
    }
  ];

  // æ¯ä¸ªå­£èŠ‚æŒç»­çš„æ¸¸æˆæ—¥æ•°ï¼š21 å¤©
  const SEASON_LENGTH_DAYS = 21;

  // å½“å‰å­£èŠ‚ä¸‹æ ‡
  let currentSeasonIndex = 0;
  const GRID_SIZE = 4;
  const LAND_LEVEL_CONFIG = {
    1: { type: 'åŸºç¡€', fertility: 1, color: '#d8c8ae' },
    2: { type: 'è‚¥æ²ƒ', fertility: 1.2, color: '#c9d7a6' },
    3: { type: 'é­”æ³•', fertility: 1.45, color: '#c2d6f5' },
    4: { type: 'ç¥ç§˜', fertility: 1.75, color: '#d6bff5' },
    5: { type: 'ä¼ è¯´', fertility: 2.1, color: '#f5d6b1' }
  };
  const MAX_LAND_LEVEL = 5;
  const BALANCE_CONFIG = {
    unlockBaseCost: 30,
    unlockCostStep: 12,
    unlockCostRamp: 20
  };
  const upgradeCosts = { 1: 25, 2: 60, 3: 140, 4: 320 };

  const seeds = {
    basic_wheat: { id: 'basic_wheat', name: 'åŸºç¡€å°éº¦', cost: 8, growTime: 420, yield: [2,3], basePrice: 10, desc: 'çŸ­å‘¨æœŸç²®é£Ÿï¼Œé€‚åˆèµ·æ­¥ç»ƒæ‰‹ã€‚' },
    mid_corn:   { id: 'mid_corn', name: 'ç”œç‰ç±³', cost: 22, growTime: 960, yield: [2,3], basePrice: 18, desc: 'ä¸­å‘¨æœŸä½œç‰©ï¼Œæ”¶ç›Šç¨³æ­¥æå‡ã€‚' },
    high_pumpkin: { id: 'high_pumpkin', name: 'é‡‘è‰²å—ç“œ', cost: 45, growTime: 2400, yield: [1,2], basePrice: 40, desc: 'é•¿å‘¨æœŸé«˜ä»·ä½œç‰©ï¼Œè€å¿ƒç­‰å¾…å¤§ä¸°æ”¶ã€‚' },

    // new seed: è„†çš®èåœ
    fast_radish: {
      id: 'fast_radish',
      name: 'è„†çš®èåœ',
      cost: 6,
      growTime: 300,
      yield: [2, 4],
      basePrice: 8,
      desc: 'è¶…çŸ­å‘¨æœŸã€å¤šäº§çš„å°èœï¼Œé€‚åˆåˆ·æ¯æ—¥ä»»åŠ¡ã€‚' // new seed
    },

    // new seed: è‰è“
    berry: {
      id: 'berry',
      name: 'è‰è“',
      cost: 30,
      growTime: 1500,
      yield: [2, 3],
      basePrice: 28,
      desc: 'ç”œç¾çš„è‰è“ï¼Œé€‚åˆä¸­åæœŸé«˜ä»·å€¼è®¢å•ã€‚' // new seed
    }
  };

  const CROP_PROGRESS_COLORS = {
    basic_wheat: '#a6c48a',   // å°éº¦ï¼šæŸ”å’Œè‰ç»¿
    mid_corn: '#f2c14e',      // ç‰ç±³ï¼šæš–é»„è‰²
    high_pumpkin: '#e58f65'   // å—ç“œï¼šæ©™è‰²
  };

  const harvestRawMap = {
    basic_wheat: 'wheat',
    mid_corn: 'corn',
    high_pumpkin: 'pumpkin',
    fast_radish: 'radish',     // new seed mapping
    berry: 'strawberry'        // new seed mapping
  };

  const processingRecipes = {
    bread: { id: 'bread', name: 'é¢åŒ…', input: { wheat: 3 }, timeMinutes: 6 * 60, output: { bread: 1 }, unlockLevel: 0, tip: 'ç”¨å°éº¦å‘é…¿å‡ºçš„é¦™æ°”é¢åŒ…ã€‚' },
    popcorn: { id: 'popcorn', name: 'çˆ†ç±³èŠ±', input: { corn: 2 }, timeMinutes: 8 * 60, output: { popcorn: 1 }, unlockLevel: 0, tip: 'é…¥è„†çš„ç‰ç±³é›¶é£Ÿã€‚' },
    pumpkin_pie: { id: 'pumpkin_pie', name: 'å—ç“œæ´¾', input: { pumpkin: 1, wheat: 1 }, timeMinutes: 12 * 60, output: { pumpkin_pie: 1 }, unlockLevel: 2, tip: 'é«˜å€¼é…æ–¹ï¼ŒèŠ‚æ—¥é™å®šç¾å‘³ã€‚' },

    // new product: è…Œèåœ
    radish_pickles: {
      id: 'radish_pickles',
      name: 'è…Œèåœ',
      input: { radish: 3 },
      timeMinutes: 3 * 60,
      output: { radish_pickles: 1 },
      unlockLevel: 0,
      tip: 'æ¸…çˆ½å¼€èƒƒçš„å°èœï¼Œé€‚åˆå¿«é€Ÿå‘¨è½¬ã€‚' // new product
    },

    // new product: è‰è“é…±
    berry_jam: {
      id: 'berry_jam',
      name: 'è‰è“é…±',
      input: { strawberry: 3, wheat: 1 },
      timeMinutes: 10 * 60,
      output: { berry_jam: 1 },
      unlockLevel: 1,
      tip: 'ç”œç”œçš„è‰è“é…±ï¼Œé«˜ä»·å€¼è®¢å•å¸¸å®¢ã€‚' // new product
    }
  };



  // ========= å¤©èµ‹ï¼ˆPerkï¼‰ç³»ç»Ÿ =========
  const PERKS = {
    moreYield: {
      id: 'moreYield',
      name: 'ä¸°æ”¶ç”°',
      desc: 'æ‰€æœ‰ä½œç‰©äº§é‡ +5%ã€‚',
      effect: { yieldBonus: 0.05 }
    }
  };

  // perk: æ‰€æœ‰å¤©èµ‹æœ€ç»ˆæ±‡æ€»æˆä¸€ä¸ªå…¨å±€ä¿®æ­£ç³»æ•°å¯¹è±¡
  let globalModifiers = {
    yieldBonus: 0  // äº§é‡åŠ æˆ
  };
  const goodsPrices = {
    bread: 28,
    popcorn: 38,
    pumpkin_pie: 65,
    radish_pickles: 24, // new
    berry_jam: 60       // new
  };
  const RAW_SELL_PRICES = {
    wheat: 4,
    corn: 7,
    pumpkin: 15,
    radish: 3,          // new
    strawberry: 14      // new
  };
  const GOODS_SELL_PRICES = {
    bread: 23,
    popcorn: 31,
    pumpkin_pie: 54,
    radish_pickles: 20, // new
    berry_jam: 50       // new
  };
  const MARKET_PRICE_TEMPLATE = {
    wheat: 1,
    corn: 1,
    pumpkin: 1,
    radish: 1,
    strawberry: 1,
    bread: 1,
    popcorn: 1,
    pumpkin_pie: 1,
    radish_pickles: 1,
    berry_jam: 1
  };
  const MAX_ORDERS_BASE = 2;

  let grid = [];
  let gold = 300;
  let gameTimeMinutes = 0;
  let lastTick = Date.now();
  let tipMessage = 'å…ˆè§£é”å‡ å—åœŸåœ°å†å¼€å§‹ç§æ¤å§ã€‚';
  let selectedSeed = '';
  let selectedTile = -1;
  let mode = 'normal'; // normal | swap
  let swapSelection = [];
  let inventory = { basic_wheat: 2, mid_corn: 0, high_pumpkin: 0, fast_radish: 0, berry: 0 }; // new seed
  let storage = {
    raw: {
      wheat: 0,
      corn: 0,
      pumpkin: 0,
      radish: 0,      // new raw
      strawberry: 0   // new raw
    },
    goods: {
      bread: 0,
      popcorn: 0,
      pumpkin_pie: 0,
      radish_pickles: 0, // new product
      berry_jam: 0       // new product
    }
  };
  let processingSlots = [];     // å½“å‰æ­£åœ¨åŠ å·¥çš„æ‰€æœ‰åŠ å·¥ä½
  let maxProcessingSlots = 1;   // å½“å‰è§£é”çš„åŠ å·¥ä½æ•°é‡ï¼Œåˆå§‹ä¸º 1
  let activeOrders = [];
  let lastGameDay = 1;
  let playerStats = { reputation: 0, perks: [] };
  let achievementsState = { harvestCount: 0, ordersDone: 0, highRecipe: false, claimed: {} };
  let dailyQuestState = null;
  let mainQuestState = { step: 0, completed: false };
  let marketPriceModifier = { ...MARKET_PRICE_TEMPLATE };
  let lastReadyCount = 0;
  let visualEffects = [];
  let pendingHarvestDecision = null; // æ”¶è·æ—¶ç­‰å¾…ç©å®¶é€‰æ‹©çš„å†³ç­–æ•°æ®

  const achievementsConfig = [
    { id: 'new_farmer', name: '\u65b0\u624b\u519c\u592b', desc: '\u7d2f\u8ba1\u6536\u83b7 10 \u6b21\u4f5c\u7269', isCompleted: state => state.harvestCount >= 10 },
    { id: 'order_master', name: '\u8ba2\u5355\u80fd\u624b', desc: '\u7d2f\u8ba1\u5b8c\u6210 3 \u5f20\u8ba2\u5355', isCompleted: state => state.ordersDone >= 3 },
    { id: 'high_recipe', name: '\u9ad8\u7ea7\u914d\u65b9\u8fbe\u4eba', desc: '\u505a\u51fa\u4e00\u6b21\u9ad8\u7ea7\u914d\u65b9', isCompleted: state => !!state.highRecipe }
  ];
  const achievementRewards = {
    new_farmer: { gold: 50, reputation: 1 },
    order_master: { gold: 120, reputation: 2 },
    high_recipe: { gold: 100, reputation: 1 }
  };

  // ========= åœŸåœ°çš®è‚¤ / å°è£…é¥° =========

  // åˆ¤æ–­æŸä¸ªæˆå°±æ˜¯å¦å·²ç»å®Œæˆ
  function isAchievementCompleted(id) {
    const cfg = achievementsConfig.find(a => a.id === id);
    return cfg ? cfg.isCompleted(achievementsState) : false;
  }

  // æ ¹æ®å½“å‰æˆå°± + åœŸåœ°ç­‰çº§ï¼Œç»™ tile é€‰ä¸€ä¸ªçš®è‚¤
  function updateTileSkin(tile) {
    if (!tile) return;

    // Lv3 ä»¥ä¸‹ä¸æ˜¾ç¤ºçš®è‚¤
    if (tile.landLevel < 3) {
      tile.skin = null;
      return;
    }

    // ç®€å•ä¼˜å…ˆçº§è§„åˆ™ï¼ˆé«˜çº§æˆå°±è¦†ç›–ä½çº§æˆå°±ï¼‰
    if (isAchievementCompleted('high_recipe')) {
      tile.skin = 'scarecrow'; // å®Œæˆå—ç“œæ´¾ â†’ ç¨»è‰äºº
    } else if (isAchievementCompleted('order_master')) {
      tile.skin = 'windmill';  // è®¢å•è¾¾äºº â†’ å°é£è½¦
    } else if (isAchievementCompleted('new_farmer')) {
      tile.skin = 'flower';    // æ–°æ‰‹å†œå¤« â†’ å°èŠ±ä¸›
    } else {
      tile.skin = null;
    }
  }

  // ä¸€æ¬¡æ€§åˆ·æ–°æ‰€æœ‰åœ°å—çš®è‚¤
  function refreshAllTileSkins() {
    grid.forEach(updateTileSkin);
  }

  const canvas = document.getElementById('gameBoard');
  const ctx = canvas.getContext('2d');

  // ========= åˆå§‹åŒ– =========
  function landLevelToType(level) { return (LAND_LEVEL_CONFIG[level] || LAND_LEVEL_CONFIG[1]).type; }
  function landLevelToFertility(level) { return (LAND_LEVEL_CONFIG[level] || LAND_LEVEL_CONFIG[1]).fertility; }
  function landLevelToColor(level) { return (LAND_LEVEL_CONFIG[level] || LAND_LEVEL_CONFIG[1]).color; }

  function updateTileLevel(tile, level) {
    tile.landLevel = level;
    tile.landType = landLevelToType(level);
    tile.land = tile.landType;
    tile.fertility = landLevelToFertility(level);
    updateTileSkin(tile); // æ–°å¢ï¼šç­‰çº§å˜åŒ–æ—¶åˆ·æ–°çš®è‚¤
  }

  function createTile(locked = true, level = 1) {
    return {
      locked,
      landLevel: level,
      landType: landLevelToType(level),
      land: landLevelToType(level),
      fertility: landLevelToFertility(level),
      crop: null,
      plantedAt: 0,
      growTime: 0,
      ready: false,
      skin: null // æ–°å¢ï¼šåœŸåœ°çš®è‚¤ï¼ˆçº¯å¤–è§‚ç”¨ï¼‰
    };
  }

  function initGrid() {
    grid = new Array(GRID_SIZE * GRID_SIZE).fill(0).map(() => createTile(true, 1));
    for (let i = 0; i < 3; i++) {
      grid[i].locked = false;
      updateTileLevel(grid[i], 1);
    }
  }

  function init() {
    initGrid();
    renderSeedSelect();
    renderShop();
    ensureTestAccount();
    loadAccountsToSelect();
    bindCanvas();
    refreshMarketPrices(1);
    updateSeasonByGameTime();
    renderSeasonCard();
    updateUI();
    setMode('normal');
    initRightTabs();
    setInterval(gameLoop, 1000);
    animationLoop();
  }

  function bindCanvas() {
    canvas.addEventListener('click', evt => {
      const rect = canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      const tileSize = canvas.width / GRID_SIZE;
      const tx = Math.floor(x / tileSize);
      const ty = Math.floor(y / tileSize);
      const idx = ty * GRID_SIZE + tx;
      handleTileClick(idx);
    });
  }

 
  // ========= UI æ¸²æŸ“ =========
  function renderSeedSelect() {
    const sel = document.getElementById('seedSelect');
    if (!sel) return;
    sel.innerHTML = '';
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'è¯·é€‰æ‹©ç§å­';
    sel.appendChild(placeholder);
    Object.values(seeds).forEach(seed => {
      const opt = document.createElement('option');
      opt.value = seed.id;
      opt.textContent = `${seed.name}ï½œæˆæœ¬ ${seed.cost} é‡‘å¸`;
      sel.appendChild(opt);
    });
    sel.value = selectedSeed || '';
    sel.onchange = () => {
      selectedSeed = sel.value;
      if (!selectedSeed) { tip('è¯·é€‰æ‹©ç§å­'); return; }
      if (seeds[selectedSeed]) {
        tip(`å·²é€‰æ‹© ${seeds[selectedSeed].name}`);
      } else {
        tip('è¯·é€‰æ‹©ç§å­');
      }
    };
  }

  function renderShop() {
    const wrap = document.getElementById('shopList');
    wrap.innerHTML = '';
    Object.values(seeds).forEach(seed => {
      const row = document.createElement('div');
      row.className = 'list-line';
      row.innerHTML = `
        <div>
          <div>${seed.name}</div>
          <div class="muted">ä»·æ ¼: ${seed.cost} | æˆç†Ÿ: ${formatDuration(seed.growTime)}</div>
        </div>`;
      const btn = document.createElement('button');
      btn.className = 'btn small primary';
      btn.textContent = 'è´­ä¹°';
      btn.onclick = () => buySeed(seed.id);
      row.appendChild(btn);
      wrap.appendChild(row);
    });
  }

  function renderInventory() {
    const wrap = document.getElementById('inventoryList');
    wrap.innerHTML = '';
    Object.keys(seeds).forEach(id => {
      const count = inventory[id] || 0;
      const div = document.createElement('div');
      div.className = 'list-line';
      div.innerHTML = `<span>${seeds[id].name}</span><span class="muted">x${count}</span>`;
      wrap.appendChild(div);
    });
  }

  function renderStorage() {
    const r = storage.raw;
    const g = storage.goods;
    document.getElementById('storageRaw').textContent =
      `åŸæ–™ï¼šå°éº¦ x${r.wheat} | ç‰ç±³ x${r.corn} | å—ç“œ x${r.pumpkin} | èåœ x${r.radish} | è‰è“ x${r.strawberry}`;
    document.getElementById('storageGoods').textContent =
      `æˆå“ï¼šé¢åŒ… x${g.bread} | çˆ†ç±³èŠ± x${g.popcorn} | å—ç“œæ´¾ x${g.pumpkin_pie} | è…Œèåœ x${g.radish_pickles} | è‰è“é…± x${g.berry_jam}`;
  }

  function renderMarket() {
    const wrap = document.getElementById('marketList');
    if (!wrap) return;
    wrap.innerHTML = '';
    const makeTag = (mod) => {
      const tag = document.createElement('span');
      tag.className = 'tag';
      if (mod < 0.95) { tag.classList.add('danger'); tag.textContent = 'ä»·æ ¼ä½è¿·'; }
      else if (mod > 1.05) { tag.classList.add('success'); tag.textContent = 'ä»·æ ¼é«˜æ¶¨ Â· æ¨èå‡ºå”®'; }
      else { tag.textContent = 'ä»·æ ¼æ­£å¸¸'; }
      return tag;
    };
    const addLine = (kind, id, name, count) => {
      const price = getMarketPrice(kind, id);
      const mod = marketPriceModifier[id] ?? 1;
      const card = document.createElement('div');
      card.className = 'market-item-card';

      const title = document.createElement('div');
      title.className = 'market-title';
      title.textContent = name;
      card.appendChild(title);

      const meta = document.createElement('div');
      meta.className = 'market-meta';
      meta.innerHTML = `<span>åº“å­˜ <strong>${count}</strong></span><span>å•ä»· ${price} é‡‘å¸</span>`;
      card.appendChild(meta);

      const tag = makeTag(mod);
      card.appendChild(tag);

      const actions = document.createElement('div');
      actions.className = 'market-actions';
      const btnAll = document.createElement('button');
      btnAll.className = 'btn small primary full';
      btnAll.textContent = 'å…¨éƒ¨å‡ºå”®';
      btnAll.disabled = count <= 0;
      btnAll.onclick = () => sellItem(kind, id);
      actions.appendChild(btnAll);
      card.appendChild(actions);

      wrap.appendChild(card);
    };
    Object.entries(storage.raw).forEach(([k,v]) => addLine('raw', k, rawName(k), v));
    Object.entries(storage.goods).forEach(([k,v]) => addLine('goods', k, goodsName(k), v));
  }

  function formatDuration(mins) {
    const h = Math.floor(mins / 60);
    const m = Math.round(mins % 60);
    if (h <= 0) return `${m} åˆ†é’Ÿ`;
    if (m === 0) return `${h} å°æ—¶`;
    return `${h} å°æ—¶ ${m} åˆ†é’Ÿ`;
  }

  function formatETA(slot) {
    const finish = (slot.startedAt || 0) + (slot.timeTotal || 0);
    const day = Math.floor(finish / DAY_MINUTES) + 1;
    const dayMinutes = Math.floor(finish % DAY_MINUTES);
    const h = Math.floor(dayMinutes / 60).toString().padStart(2,'0');
    const m = Math.floor(dayMinutes % 60).toString().padStart(2,'0');
    return `é¢„è®¡åœ¨ç¬¬${day}å¤© ${h}:${m} å®Œæˆ`;
  }

  function calcExtraGain(recipe) {
    const rawValue = Object.entries(recipe.input || {}).reduce((sum,[k,v]) => sum + (RAW_SELL_PRICES[k] || 0) * v, 0);
    const outValue = Object.entries(recipe.output || {}).reduce((sum,[k,v]) => sum + (GOODS_SELL_PRICES[k] || 0) * v, 0);
    return outValue - rawValue;
  }

  function renderProcessing() {
    const status = document.getElementById('processingStatus');
    const btns = document.getElementById('processingBtns');
    const capEl = document.getElementById('processingCapacityText');
    const upgradeWrap = document.getElementById('processingUpgrade');

    if (btns) btns.innerHTML = '';
    if (status) status.innerHTML = '';

    // æ˜¾ç¤ºå½“å‰åŠ å·¥ä½å ç”¨æƒ…å†µ
    if (capEl) {
      capEl.textContent = 'åŠ å·¥ä½ï¼š' + processingSlots.length + ' / ' + maxProcessingSlots;
    }

    // æ˜¾ç¤ºæ¯ä¸ªæ­£åœ¨åŠ å·¥çš„åŠ å·¥ä½
    if (!processingSlots.length) {
      if (status) status.textContent = 'ç©ºé—²ä¸­';
    } else if (status) {
      processingSlots.forEach(function (slot, index) {
        const recipe = processingRecipes[slot.recipeId];
        if (!recipe) return;

        const elapsed = gameTimeMinutes - slot.startedAt;
        const p = Math.min(1, elapsed / slot.timeTotal);

        const card = document.createElement('div');
        card.className = 'processing-card';

        const title = document.createElement('div');
        title.className = 'processing-title';
        title.textContent = 'åŠ å·¥ä½ ' + (index + 1) + 'ï¼š' + recipe.name;
        card.appendChild(title);

        const eta = document.createElement('div');
        eta.className = 'processing-eta';
        eta.textContent = formatETA(slot);
        card.appendChild(eta);

        const bar = document.createElement('div');
        bar.className = 'progress';
        bar.innerHTML = '<span style=\"width:' + p * 100 + '%\"></span>';
        card.appendChild(bar);

        status.appendChild(card);
      });
    }

    // é…æ–¹æŒ‰é’®ï¼ˆå¯ä»¥åœ¨æœ‰ç©ºé—²åŠ å·¥ä½æ—¶ç»§ç»­æ’æ–°å•ï¼‰
    Object.values(processingRecipes).forEach(function (recipe) {
      const level = getReputationLevel();
      const locked = level < recipe.unlockLevel;
      const enough = hasInput(recipe.input);
      const busy = processingSlots.length >= maxProcessingSlots; // æ²¡æœ‰ç©ºé—²åŠ å·¥ä½
      const isActive = processingSlots.some(function (slot) {
        return slot.recipeId === recipe.id;
      });

      const card = document.createElement('div');
      card.className = 'recipe-card';
      if (isActive) card.classList.add('active');

      const head = document.createElement('div');
      head.className = 'recipe-head';
      head.innerHTML =
        '<strong>' +
        recipe.name +
        '</strong><span class=\"muted\">' +
        formatDuration(recipe.timeMinutes) +
        '</span>';
      card.appendChild(head);

      const io = document.createElement('div');
      io.className = 'recipe-io muted';
      const inputStr = Object.entries(recipe.input)
        .map(function ([k, v]) {
          return rawName(k) + ' x' + v;
        })
        .join(' + ');
      const outputStr = Object.entries(recipe.output)
        .map(function ([k, v]) {
          return goodsName(k) + ' x' + v;
        })
        .join(' + ');
      io.textContent = inputStr + ' â†’ ' + outputStr;
      card.appendChild(io);

      const gain = calcExtraGain(recipe);
      const gainLine = document.createElement('div');
      gainLine.className = 'recipe-gain';
      gainLine.textContent =
        'é¢„è®¡é¢å¤–æ”¶ç›Šï¼š' + (gain >= 0 ? '+' : '') + gain + ' é‡‘å¸';
      card.appendChild(gainLine);

      if (locked) {
        const lockInfo = document.createElement('div');
        lockInfo.className = 'muted';
        lockInfo.textContent = 'å£°æœ›è¾¾åˆ° ' + recipe.unlockLevel + ' çº§è§£é”';
        card.appendChild(lockInfo);
      }

      const btnWrap = document.createElement('div');
      btnWrap.className = 'recipe-footer';
      const btn = document.createElement('button');
      btn.className = 'btn small full';
      btn.textContent = locked
        ? recipe.name + 'ï¼ˆå£°æœ›' + recipe.unlockLevel + 'çº§è§£é”ï¼‰'
        : 'åŠ å·¥ ' + recipe.name;
      btn.disabled = busy || locked || !enough;
      btn.onclick = function () {
        startProcessing(recipe.id);
      };
      btnWrap.appendChild(btn);
      card.appendChild(btnWrap);

      if (btns) btns.appendChild(card);
    });

    // è´­ä¹°åŠ å·¥ä½ UI
    if (upgradeWrap) {
      upgradeWrap.innerHTML = '';
      if (maxProcessingSlots < PROCESS_SLOT_MAX) {
        const cost = getNextProcessSlotCost();
        const btn = document.createElement('button');
        btn.className = 'btn small secondary full';
        btn.textContent = 'è´­ä¹°æ–°çš„åŠ å·¥ä½ï¼ˆ' + cost + ' é‡‘å¸ï¼‰';
        btn.disabled = gold < cost;
        btn.onclick = buyProcessSlot;
        upgradeWrap.appendChild(btn);

        const hint = document.createElement('div');
        hint.className = 'muted';
        hint.style.marginTop = '4px';
        hint.textContent = 'æœ€å¤šå¯åŒæ—¶åŠ å·¥ ' + PROCESS_SLOT_MAX + ' æ‰¹å•†å“ã€‚';
        upgradeWrap.appendChild(hint);
      } else {
        const hint = document.createElement('div');
        hint.className = 'muted';
        hint.textContent = 'åŠ å·¥ä½å·²å…¨éƒ¨è§£é”ã€‚';
        upgradeWrap.appendChild(hint);
      }
    }
  }

  function renderOrders() {
    const wrap = document.getElementById('ordersList');
    wrap.innerHTML = '';
    const pending = activeOrders.filter(o => o.status === 'pending');
    if (pending.length === 0) { wrap.textContent = 'æš‚æ— è®¢å•'; return; }
    const currentDay = Math.floor(gameTimeMinutes / DAY_MINUTES) + 1;
    pending.forEach(order => {
      const remainingDays = order.deadlineDay - currentDay;
      if (remainingDays <= -1) return;
      const card = document.createElement('div');
      card.className = 'order-card';

      const head = document.createElement('div');
      head.className = 'order-head';
      const title = document.createElement('strong');
      title.textContent = order.title;
      head.appendChild(title);
      const tag = document.createElement('span');
      tag.className = 'tag';
      if (remainingDays <= 1) { tag.classList.add('danger'); tag.textContent = 'ç´§æ€¥'; }
      else if (remainingDays === 2) { tag.textContent = 'å³å°†æˆªæ­¢'; }
      else { tag.classList.add('success'); tag.textContent = 'å®½è£•'; }
      head.appendChild(tag);
      card.appendChild(head);

      const need = Object.entries(order.require).map(([k,v]) => `${goodsName(k)} x${v}`).join('ï¼Œ');
      const needLine = document.createElement('div');
      needLine.className = 'muted';
      needLine.textContent = `éœ€æ±‚ï¼š${need}`;
      card.appendChild(needLine);

      const reward = document.createElement('div');
      reward.className = 'muted';
      reward.textContent = `å¥–åŠ±ï¼šé‡‘å¸ ${order.reward.gold} / å£°æœ› ${order.reward.reputation}${order.reward.seeds ? ` / ç§å­ ${seeds[order.reward.seeds].name}` : ''}`;
      card.appendChild(reward);

      const deadline = document.createElement('div');
      deadline.className = 'muted';
      const left = Math.max(0, remainingDays);
      deadline.textContent = `æˆªæ­¢åˆ°ç¬¬ ${order.deadlineDay} å¤©ï¼Œè¿˜å‰© ${left} å¤©`;
      card.appendChild(deadline);

      const can = canDeliver(order);
      if (!can) {
        const missing = Object.entries(order.require).map(([k,v]) => {
          const have = storage.goods[k] || 0;
          const diff = v - have;
          return diff > 0 ? `${goodsName(k)} x${diff}` : null;
        }).filter(Boolean);
        if (missing.length) {
          const missLine = document.createElement('div');
          missLine.className = 'muted';
          missLine.textContent = `ç¼ºå°‘ï¼š${missing.join('ï¼Œ')}`;
          card.appendChild(missLine);
        }
      }

      const btn = document.createElement('button');
      btn.className = can ? 'btn small primary full' : 'btn small full';
      btn.textContent = can ? 'äº¤ä»˜è®¢å•' : 'åº“å­˜ä¸è¶³';
      btn.disabled = !can;
      btn.onclick = () => deliverOrder(order.id);
      card.appendChild(btn);

      wrap.appendChild(card);
    });
  }

  
// æ›¿æ¢åçš„ï¼šæ˜¾ç¤ºå½“å‰å£°æœ›ä¸å£°æœ›ç­‰çº§

  // æ›¿æ¢åçš„ï¼šæ˜¾ç¤ºå½“å‰å£°æœ›ä¸å£°æœ›ç­‰çº§
  function renderReputation() {
    const level = getReputationLevel();
    const rep = playerStats.reputation || 0;

    let levelText;
    switch (level) {
      case 0:
        levelText = '0çº§Â·æ— åå†œå¤«';
        break;
      case 1:
        levelText = '1çº§Â·å°æœ‰åæ°”';
        break;
      case 2:
        levelText = '2çº§Â·è¿œè¿‘é—»å';
        break;
      default:
        levelText = '3çº§Â·ä¼ è¯´å†œåœºä¸»';
        break;
    }

    const text = `å£°æœ›å€¼ ${rep}ï¼Œ${levelText}`;
    const el = document.getElementById('reputationInfo');
    if (el) el.textContent = text;

    // perk: æ˜¾ç¤ºå·²è·å¾—çš„å¤©èµ‹
    const perksEl = document.getElementById('reputationPerks');
    if (perksEl) {
      const perks = playerStats.perks || [];
      if (!perks.length) {
        perksEl.textContent = 'å·²è·å¾—å¤©èµ‹ï¼šæ— ';
      } else {
        const names = perks
          .map(id => PERKS[id])
          .filter(Boolean)
          .map(p => p.name);
        perksEl.textContent = 'å·²è·å¾—å¤©èµ‹ï¼š' + names.join('ï¼Œ');
      }
    }
  }


// æ›¿æ¢åçš„ï¼šæˆå°±é€»è¾‘ + æ–‡å­—å±•ç¤º
function updateAchievements() {
  const summary = document.getElementById('achievements');
  const details = document.getElementById('achievementDetails');
  if (!summary || !details) return;

  if (!achievementsState.claimed) achievementsState.claimed = {};

  let completed = 0;
  const lines = [];
  const rewarded = [];

  achievementsConfig.forEach(cfg => {
    const done = cfg.isCompleted(achievementsState);
    if (done) completed += 1;

    let extra = '';
    if (cfg.id === 'new_farmer') {
      extra = `ï¼ˆå½“å‰æ”¶è·æ¬¡æ•°ï¼š${achievementsState.harvestCount}ï¼‰`;
    } else if (cfg.id === 'order_master') {
      extra = `ï¼ˆå½“å‰å·²å®Œæˆè®¢å•ï¼š${achievementsState.ordersDone}ï¼‰`;
    } else if (cfg.id === 'high_recipe' && achievementsState.highRecipe) {
      extra = 'ï¼ˆå·²åˆ¶ä½œè¿‡é«˜çº§é…æ–¹ï¼‰';
    }

    const mark = done ? 'âœ“' : 'â€¦';
    lines.push(
      `<div class="list-line muted"><span>[${mark}] ${cfg.name}ï¼š${cfg.desc}${extra}</span></div>`
    );

    // é¦–æ¬¡å®Œæˆæ—¶å‘æ”¾å¥–åŠ±
    if (done && !achievementsState.claimed[cfg.id]) {
      const reward = achievementRewards[cfg.id];
      achievementsState.claimed[cfg.id] = true;
      if (reward) {
        gold += reward.gold || 0;
        addReputation(reward.reputation || 0);
        rewarded.push({ name: cfg.name, reward });
      }
    }
  });

  // é¡¶éƒ¨æ¦‚è§ˆ
  summary.textContent = `å·²å®Œæˆ ${completed} / ${achievementsConfig.length}`;
  // è¯¦ç»†åˆ—è¡¨
  details.innerHTML = lines.join('');

  // æœ‰æ–°æˆå°±å®Œæˆæ—¶æç¤º
  if (rewarded.length) {
    const msg = rewarded
      .map(r => {
        const parts = [];
        if (r.reward.gold) parts.push(`é‡‘å¸ +${r.reward.gold}`);
        if (r.reward.reputation) parts.push(`å£°æœ› +${r.reward.reputation}`);
        return `${r.name}ï¼ˆ${parts.join('ï¼Œ')}ï¼‰`;
      })
      .join('ï¼›');
    tip(`æˆå°±è¾¾æˆï¼${msg}`);
    showToast(`æˆå°±è¾¾æˆï¼${msg}`);
  }

  // æˆå°±ä¼šå½±å“åœŸåœ°å°è£…é¥°çš®è‚¤
  refreshAllTileSkins();
}

function renderDailyQuest() {
    const wrap = document.getElementById('dailyQuest');
    if (!wrap) return;
    if (!dailyQuestState) {
      wrap.textContent = 'ç­‰å¾…åˆ·æ–°ä»»åŠ¡';
      return;
    }
    if (dailyQuestState.completed) {
      wrap.textContent = 'ä»»åŠ¡å·²å®Œæˆï¼Œå¥–åŠ±å·²é¢†å–';
      return;
    }
    const { type, target, progress, reward } = dailyQuestState;
    const safeTarget = target || 0;
    const cur = Math.min(progress ?? 0, safeTarget);
    const rewardGold = reward?.gold ?? 0;
    const rewardRep = reward?.reputation ?? 0;
    if (type === 'harvest') {
      wrap.textContent = `ä»»åŠ¡ï¼šæ”¶è· ${safeTarget} æ¬¡ï¼ˆå½“å‰ ${cur} / ${safeTarget}ï¼‰ï¼Œå¥–åŠ±ï¼šé‡‘å¸ ${rewardGold}ï¼Œå£°æœ› ${rewardRep}`;
    } else {
      wrap.textContent = `ä»»åŠ¡ï¼šäº¤ä»˜ ${safeTarget} å¼ è®¢å•ï¼ˆå½“å‰ ${cur} / ${safeTarget}ï¼‰ï¼Œå¥–åŠ±ï¼šé‡‘å¸ ${rewardGold}ï¼Œå£°æœ› ${rewardRep}`;
    }
  }

  function renderMainQuest() {
    const el = document.getElementById('mainQuest');
    if (!el) return;
    if (mainQuestState.completed) {
      el.textContent = 'ä¸»çº¿ç›®æ ‡ï¼šå·²å®Œæˆå½“å‰ç« èŠ‚ï¼Œæ•¬è¯·æœŸå¾…åç»­å†…å®¹ã€‚';
      return;
    }
    if (mainQuestState.step === 0) {
      el.textContent = 'ä¸»çº¿ç›®æ ‡ï¼šåˆæˆç¬¬ä¸€å— Lv3 åœŸåœ°ã€‚';
    } else if (mainQuestState.step === 1) {
      el.textContent = 'ä¸»çº¿ç›®æ ‡ï¼šåˆ¶ä½œç¬¬ä¸€ä»½é¢åŒ…ã€‚';
    } else if (mainQuestState.step === 2) {
      el.textContent = 'ä¸»çº¿ç›®æ ‡ï¼šå®Œæˆ 3 å¼ è®¢å•ã€‚';
    } else {
      el.textContent = 'ä¸»çº¿ç›®æ ‡ï¼šå·²å®Œæˆå½“å‰ç« èŠ‚ï¼Œæ•¬è¯·æœŸå¾…åç»­å†…å®¹ã€‚';
    }
  }

  // season: åˆ·æ–°å­£èŠ‚å¡ç‰‡ UI
  function renderSeasonCard() {
    const season = getCurrentSeason();
    const nameEl = document.getElementById('seasonName');
    const descEl = document.getElementById('seasonDesc');
    if (season && nameEl) {
      nameEl.textContent = season.name;
    }
    if (season && descEl) {
      descEl.textContent = season.desc;
    }
  }

  function renderLandInfo(idx) {
    const el = document.getElementById('landInfo');
    el.innerHTML = '';
    if (idx < 0) { el.textContent = 'æœªé€‰æ‹©åœ°å—ã€‚'; return; }
    const tile = grid[idx];
    const status = document.createElement('div');
    status.textContent = tile.locked ? 'çŠ¶æ€ï¼šå·²é”å®š' : `çŠ¶æ€ï¼šLv.${tile.landLevel} ${tile.landType}`;
    el.appendChild(status);

    const soil = document.createElement('div');
    soil.className = 'muted';
    soil.textContent = `åœŸå£¤è‚¥åŠ› ${Math.round(tile.fertility * 100)}%`;
    el.appendChild(soil);

    if (tile.locked) {
      const lockTip = document.createElement('div');
      lockTip.className = 'muted';
      lockTip.textContent = 'è§£é”åæ‰èƒ½ç§æ¤ã€äº¤æ¢æˆ–åˆæˆã€‚';
      el.appendChild(lockTip);
    } else {
      if (tile.crop) {
        const cfg = seeds[tile.crop.seedId];
        const elapsed = gameTimeMinutes - tile.plantedAt;
        const p = Math.min(1, elapsed / tile.growTime);
        const cropInfo = document.createElement('div');
        cropInfo.textContent = `ä½œç‰©ï¼š${cfg.name} | ç”Ÿé•¿ ${Math.floor(p*100)}%${tile.ready ? 'ï¼ˆå¯æ”¶è·ï¼‰' : ''}`;
        el.appendChild(cropInfo);
      } else {
        const emptyInfo = document.createElement('div');
        emptyInfo.textContent = 'ä½œç‰©ï¼šæ— ';
        el.appendChild(emptyInfo);
      }
    }

    const btnWrap = document.createElement('div');
    btnWrap.style.marginTop = '6px';
    if (tile.locked) {
      const cost = getUnlockCost();
      const btn = document.createElement('button');
      btn.className = 'btn small primary';
      btn.textContent = `è§£é”åœ°å—ï¼ˆ${cost} é‡‘å¸ï¼‰`;
      btn.onclick = () => unlockTile(idx);
      btnWrap.appendChild(btn);
    } else {
      if (tile.landLevel >= MAX_LAND_LEVEL) {
        const maxInfo = document.createElement('div');
        maxInfo.className = 'muted';
        maxInfo.textContent = 'å·²è¾¾æœ€é«˜ç­‰çº§ã€‚';
        btnWrap.appendChild(maxInfo);
      } else {
        const cost = upgradeCosts[tile.landLevel];
        const btn = document.createElement('button');
        btn.className = 'btn small secondary';
        btn.textContent = `å‡çº§åœ°å—ï¼ˆ${cost} é‡‘å¸ï¼‰`;
        btn.disabled = !!tile.crop || gold < cost;
        btn.onclick = () => upgradeTile(idx);
        btnWrap.appendChild(btn);
        if (tile.crop) {
          const warn = document.createElement('div');
          warn.className = 'muted';
          warn.textContent = 'åœ°å—å·²æœ‰ä½œç‰©ï¼Œè¯·å…ˆæ”¶è·æˆ–æ¸…ç†å†å‡çº§ã€‚';
          btnWrap.appendChild(warn);
        }
      }
    }
    el.appendChild(btnWrap);
  }

  // ========= è§†è§‰ç‰¹æ•ˆ =========
  function getTileRect(idx) {
    const size = canvas.width / GRID_SIZE;
    const x = (idx % GRID_SIZE) * size;
    const y = Math.floor(idx / GRID_SIZE) * size;
    return { x, y, size };
  }

  function getTileCenter(idx) {
    const rect = getTileRect(idx);
    return { x: rect.x + rect.size / 2, y: rect.y + rect.size / 2 };
  }

  function spawnFloatingTextAt(x, y, text, color) {
    visualEffects.push({
      type: 'floatingText',
      x,
      y,
      text,
      color,
      startTime: Date.now(),
      duration: 800,
      rise: 40
    });
  }

  function spawnFloatingTextForTile(idx, text, color) {
    const center = getTileCenter(idx);
    spawnFloatingTextAt(center.x, center.y, text, color);
  }

  function spawnTileFlash(idx, color) {
    visualEffects.push({
      type: 'tileFlash',
      tileIndex: idx,
      color,
      startTime: Date.now(),
      duration: 400
    });
  }

  function drawTileSkin(tile, px, py, size) {
    if (!tile.skin) return;

    // æŠŠå›¾æ ‡ç”»åœ¨åœ°å—å³ä¸Šè§’
    const cx = px + size - 22;
    const cy = py + 22;

    ctx.save();

    if (tile.skin === 'scarecrow') {
      // ç¨»è‰äºº
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#6d4c41';
      ctx.fillStyle = '#ffeb3b';

      // å¤´
      ctx.beginPath();
      ctx.arc(cx, cy - 4, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // èº«ä½“ + æ‰‹ + è…¿
      ctx.beginPath();
      ctx.moveTo(cx, cy + 2);
      ctx.lineTo(cx, cy + 10);
      ctx.moveTo(cx - 5, cy + 4);
      ctx.lineTo(cx + 5, cy + 4);
      ctx.moveTo(cx, cy + 10);
      ctx.lineTo(cx - 4, cy + 16);
      ctx.moveTo(cx, cy + 10);
      ctx.lineTo(cx + 4, cy + 16);
      ctx.stroke();

    } else if (tile.skin === 'windmill') {
      // å°é£è½¦
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = '#90a4ae';
      ctx.fillStyle = '#ffffff';

      // å°å¡”èº«
      ctx.beginPath();
      ctx.rect(cx - 4, cy + 2, 8, 10);
      ctx.fill();
      ctx.stroke();

      // ä¸­å¿ƒæ† + å¶ç‰‡
      ctx.beginPath();
      ctx.moveTo(cx, cy - 6);
      ctx.lineTo(cx, cy + 2);
      ctx.moveTo(cx - 6, cy - 2);
      ctx.lineTo(cx + 6, cy - 2);
      ctx.moveTo(cx - 4, cy - 6);
      ctx.lineTo(cx + 4, cy + 2);
      ctx.moveTo(cx + 4, cy - 6);
      ctx.lineTo(cx - 4, cy + 2);
      ctx.stroke();

    } else if (tile.skin === 'flower') {
      // å°èŠ±ä¸›
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = '#ad1457';
      ctx.fillStyle = '#ff80ab';

      // å››ç“£èŠ±
      for (let i = 0; i < 4; i++) {
        const angle = (Math.PI / 2) * i;
        const pxPetal = cx + Math.cos(angle) * 4;
        const pyPetal = cy + Math.sin(angle) * 4;
        ctx.beginPath();
        ctx.arc(pxPetal, pyPetal, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      // èŠ±å¿ƒ
      ctx.fillStyle = '#ffeb3b';
      ctx.beginPath();
      ctx.arc(cx, cy, 3, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.restore();
  }

  function renderCanvas() {
    ctx.clearRect(0,0,canvas.width, canvas.height);
    const size = canvas.width / GRID_SIZE;
    for (let y=0; y<GRID_SIZE; y++) {
      for (let x=0; x<GRID_SIZE; x++) {
        const idx = y*GRID_SIZE+x;
        const tile = grid[idx];
        const px = x*size;
        const py = y*size;
        const color = tile.locked ? '#b7bec6' : landLevelToColor(tile.landLevel);
        ctx.fillStyle = color;
        ctx.fillRect(px+4, py+4, size-8, size-8);
        ctx.strokeStyle = '#a98b68';
        ctx.lineWidth = 2;
        ctx.strokeRect(px+4, py+4, size-8, size-8);
        if (!tile.locked) {
          ctx.fillStyle = '#324';
          ctx.font = '12px "Microsoft YaHei"';
          ctx.fillText(`Lv${tile.landLevel}`, px+10, py+18);
          if (tile.crop) {
            const cfg = seeds[tile.crop.seedId] || { id: tile.crop.seedId, name: 'æœªçŸ¥ä½œç‰©' };
            const elapsed = gameTimeMinutes - tile.plantedAt;
            const p = Math.min(1, elapsed / tile.growTime);
            const cropColor = CROP_PROGRESS_COLORS[cfg.id] || '#7fbf85';
            ctx.save();
            ctx.fillStyle = cropColor;
            ctx.globalAlpha = tile.ready ? 0.9 : 0.72;
            ctx.fillRect(px+14, py+14, size-28, (size-28)*p);
            ctx.restore();
            ctx.fillStyle = '#324';
            ctx.font = '12px "Microsoft YaHei"';
            ctx.fillText(cfg.name, px+10, py + size - 14);
            if (tile.ready) {
              ctx.strokeStyle = '#f5c542';
              ctx.lineWidth = 5;
              ctx.strokeRect(px+2, py+2, size-4, size-4);
              ctx.strokeStyle = '#ffeb8a';
              ctx.lineWidth = 2;
              ctx.strokeRect(px+5, py+5, size-10, size-10);
              ctx.fillStyle = cropColor;
              ctx.beginPath();
              ctx.arc(px + size - 14, py + 14, 10, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = '#2f3b4a';
              ctx.font = '12px "Microsoft YaHei"';
              ctx.fillText('âœ”', px + size - 19, py + 19);
            }
          }
        } else {
          ctx.fillStyle = '#fff';
          ctx.font = '14px "Microsoft YaHei"';
          ctx.fillText('é”å®š', px + size/2 - 16, py + size/2 + 4);
        }
        if (idx === selectedTile) {
          ctx.strokeStyle = '#5a9cec';
          ctx.lineWidth = 3;
          ctx.strokeRect(px+6, py+6, size-12, size-12);
        }
        drawTileSkin(tile, px, py, size);
      }
    }

    const now = Date.now();
    const nextEffects = [];
    visualEffects.forEach(effect => {
      const t = (now - effect.startTime) / effect.duration;
      if (t >= 1) return;
      if (effect.type === 'floatingText') {
        const offsetY = -effect.rise * t;
        const alpha = 1 - t;
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = effect.color;
        ctx.font = '14px "Microsoft YaHei"';
        ctx.fillText(effect.text, effect.x, effect.y + offsetY);
        ctx.restore();
      } else if (effect.type === 'tileFlash') {
        const rect = getTileRect(effect.tileIndex);
        const alpha = 1 - t;
        const pulse = 1 + 0.3 * Math.sin(t * Math.PI * 3);
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.strokeStyle = effect.color;
        ctx.lineWidth = 4 * pulse;
        ctx.strokeRect(rect.x + 4, rect.y + 4, rect.size - 8, rect.size - 8);
        ctx.restore();
      }
      nextEffects.push(effect);
    });
    visualEffects = nextEffects;
  }

  function updateTime() {
    const day = Math.floor(gameTimeMinutes / DAY_MINUTES) + 1;
    const dayMinutes = Math.floor(gameTimeMinutes % DAY_MINUTES);
    const h = Math.floor(dayMinutes / 60).toString().padStart(2,'0');
    const m = Math.floor(dayMinutes % 60).toString().padStart(2,'0');
    document.getElementById('timeInfo').textContent = `ç¬¬${day}å¤© ${h}:${m}`;
    if (day !== lastGameDay) { onNewGameDay(day); lastGameDay = day; }
  }

  function updateUI() {
    document.getElementById('goldDisplay').textContent = gold;
    document.getElementById('tipMessage').textContent = tipMessage;
    renderInventory();
    renderStorage();
    renderMarket();
    renderProcessing();
    renderOrders();
    renderReputation();
    updateFarmStats();
    renderLandInfo(selectedTile);
    updateTime();
    updateAchievements();
    renderDailyQuest();
    renderMainQuest();
    renderSeasonCard(); // season: æ›´æ–°å­£èŠ‚æ˜¾ç¤º
    renderCanvas();
  }

  // ========= äº¤äº’ =========
  function setMode(m) {
    mode = m;
    document.getElementById('modeNormal').classList.remove('primary');
    document.getElementById('modeSwap').classList.remove('primary');
    if (m === 'normal') document.getElementById('modeNormal').classList.add('primary');
    if (m === 'swap') document.getElementById('modeSwap').classList.add('primary');
    tip(`å·²åˆ‡æ¢åˆ°${m==='normal'?'æ­£å¸¸':'äº¤æ¢'}æ¨¡å¼`);
    swapSelection = [];
  }

  function handleTileClick(idx) {
    selectedTile = idx;
    const tile = grid[idx];

    if (mode === 'swap') {
      if (tile.locked) { tip('é”å®šåœ°å—æ— æ³•äº¤æ¢ã€‚'); swapSelection = []; renderUIQuick(); return; }
      swapSelection.push(idx);
      if (swapSelection.length === 2) {
        swapTiles(swapSelection[0], swapSelection[1]);
        swapSelection = [];
      } else {
        tip('è¯·é€‰æ‹©å¦ä¸€å—å·²è§£é”åœ°å—è¿›è¡Œäº¤æ¢ã€‚');
      }
      renderUIQuick();
      return;
    }

    if (tile.locked) {
      unlockTile(idx);
      renderUIQuick();
      return;
    }

    if (!tile.crop) {
      plantCrop(idx);
    } else if (tile.ready) {
      harvestCrop(idx);
    } else {
      tip('ä½œç‰©æœªæˆç†Ÿ');
    }
    renderUIQuick();
  }

  function plantCrop(idx) {
    if (!selectedSeed) { tip('è¯·é€‰æ‹©ç§å­'); return; }
    if ((inventory[selectedSeed] || 0) <= 0) { tip('ç§å­ä¸è¶³ï¼Œå»å•†åº—è¡¥è´§'); return; }
    const tile = grid[idx];
    if (tile.locked) { tip('é”å®šåœ°å—æ— æ³•ç§æ¤æˆ–äº¤æ¢ã€‚'); return; }
    if (tile.crop) { tip('è¯¥åœ°å—å·²æœ‰ä½œç‰©'); return; }
    const cfg = seeds[selectedSeed];
    tile.crop = { seedId: selectedSeed };
    tile.plantedAt = gameTimeMinutes;
    tile.growTime = calcGrowTimeForTile(cfg, tile); // season: ä½¿ç”¨å­£èŠ‚å…¬å¼
    tile.ready = false;
    inventory[selectedSeed] -= 1;
    tip(`ç§ä¸‹äº† ${cfg.name}`);
    renderUIQuick();
  }

  function harvestCrop(idx) {
    const tile = grid[idx];
    if (!tile.crop || !tile.ready) {
      tip('å°šæœªæˆç†Ÿ');
      return;
    }

    const cfg = seeds[tile.crop.seedId];
    let yieldCount = randInt(cfg.yield[0], cfg.yield[1]);

    // perk: ä¸°æ”¶ç”°å¤©èµ‹ï¼Œå¢åŠ äº§é‡
    if (globalModifiers.yieldBonus > 0) {
      yieldCount = Math.max(1, Math.round(yieldCount * (1 + globalModifiers.yieldBonus)));
    }
    const rawId = harvestRawMap[cfg.id];
    const baseGold = Math.round(cfg.basePrice * 0.5 * yieldCount);

    // è®°å½•â€œå¾…å†³ç­–â€çš„æ”¶è·ä¿¡æ¯ï¼Œä¸ç«‹å³ä¿®æ”¹ä»“åº“å’Œé‡‘å¸
    openHarvestDecisionPanel({
      tileIndex: idx,
      seedId: cfg.id,
      cropName: cfg.name,
      yieldCount: yieldCount,
      rawId: rawId,
      baseGold: baseGold
    });
  }

  function swapTiles(a, b) {
    if (grid[a].locked || grid[b].locked) { tip('é”å®šåœ°å—æ— æ³•äº¤æ¢ã€‚'); return; }
    const ca = grid[a].crop;
    const cb = grid[b].crop;
    grid[a].crop = cb;
    grid[b].crop = ca;
    tip('å·²äº¤æ¢ä¸¤å—åœ°çš„ä½œç‰©');
    renderUIQuick();
  }

  function boostTile() {
    if (selectedTile < 0) { tip('è¯·é€‰æ‹©åœ°å—'); return; }
    const tile = grid[selectedTile];
    if (tile.locked) { tip('é”å®šåœ°å—æ— æ³•åŠ é€Ÿã€‚'); return; }
    if (!tile.crop) { tip('è¯¥åœ°å—æ²¡æœ‰ä½œç‰©'); return; }
    tile.growTime = Math.max(30, Math.round(tile.growTime * 0.9));
    tip('æ–½è‚¥æˆåŠŸï¼Œç”Ÿé•¿æ—¶é—´å‡å°‘ 10%');
    renderUIQuick();
  }

  function cleanTile() {
    if (selectedTile < 0) { tip('è¯·é€‰æ‹©åœ°å—'); return; }
    const tile = grid[selectedTile];
    if (tile.locked) { tip('é”å®šåœ°å—æ— æ³•æ¸…ç†ã€‚'); return; }
    tile.crop = null;
    tile.ready = false;
    tip('å·²æ¸…ç†è¯¥åœ°å—');
    checkAutoMerge(selectedTile);
  }

  function buySeed(id) {
    const cfg = seeds[id];
    if (gold < cfg.cost) { tip('é‡‘å¸ä¸è¶³'); return; }
    gold -= cfg.cost;
    inventory[id] = (inventory[id] || 0) + 1;
    tip(`è´­ä¹° ${cfg.name} æˆåŠŸ`);
    renderUIQuick();
  }

  // ========= åœ°å—è§£é”/å‡çº§/è‡ªåŠ¨åˆæˆ =========
  function getUnlockCost() {
    const unlockedCount = grid.filter(t => !t.locked).length;
    const base = BALANCE_CONFIG.unlockBaseCost;
    const step = BALANCE_CONFIG.unlockCostStep;
    const extra = Math.max(0, unlockedCount - 5) * BALANCE_CONFIG.unlockCostRamp;
    return base + unlockedCount * step + extra;
  }

  function unlockTile(idx) {
    const tile = grid[idx];
    if (!tile.locked) { tip('è¯¥åœ°å—å·²è§£é”ã€‚'); return; }
    const cost = getUnlockCost();
    tip(`è¯¥åœ°å—å·²é”å®šï¼ŒèŠ±è´¹ ${cost} é‡‘å¸è§£é”ï¼Ÿ`);
    if (gold < cost) { tip(`è¯¥åœ°å—å·²é”å®šï¼ŒèŠ±è´¹ ${cost} é‡‘å¸è§£é”ï¼Ÿé‡‘å¸ä¸è¶³ã€‚`); return; }
    if (!confirm(`èŠ±è´¹ ${cost} é‡‘å¸è§£é”è¯¥åœ°å—ï¼Ÿ`)) { tip('å·²å–æ¶ˆè§£é”'); return; }
    gold -= cost;
    tile.locked = false;
    updateTileLevel(tile, 1);
    tile.crop = null;
    tile.ready = false;
    tile.plantedAt = 0;
    tip(`è§£é”æˆåŠŸï¼šèŠ±è´¹ ${cost} é‡‘å¸ã€‚`);
    spawnTileFlash(idx, '#fff176');
    spawnFloatingTextForTile(idx, 'æ–°åœ°å—ï¼', '#fff176');
    checkAutoMerge(idx, false, 2);
    updateMainQuestProgress();
  }

  function upgradeTile(idx) {
    const tile = grid[idx];
    if (tile.locked) { tip('è¯·å…ˆè§£é”åœ°å—ã€‚'); return; }
    if (tile.crop) { tip('åœ°å—å·²æœ‰ä½œç‰©ï¼Œè¯·å…ˆæ”¶è·æˆ–æ¸…ç†å†å‡çº§ã€‚'); return; }
    if (tile.landLevel >= MAX_LAND_LEVEL) { tip('å·²è¾¾æœ€é«˜ç­‰çº§ã€‚'); return; }
    const oldLevel = tile.landLevel;
    const cost = upgradeCosts[tile.landLevel];
    if (gold < cost) { tip('é‡‘å¸ä¸è¶³ï¼Œæ— æ³•å‡çº§ã€‚'); return; }
    gold -= cost;
    updateTileLevel(tile, Math.min(MAX_LAND_LEVEL, oldLevel + 1));
    spawnTileFlash(idx, '#ffd54f');
    spawnFloatingTextForTile(idx, `Lv${oldLevel} â†’ Lv${tile.landLevel}`, '#ffd54f');
    tip(`å‡çº§æˆåŠŸï¼Œå½“å‰ Lv.${tile.landLevel}`);
    checkAutoMerge(idx);
  }

  // ç°åœ¨è§„åˆ™ï¼šåªæœ‰ 2 çº§åŠä»¥ä¸ŠåœŸåœ°ä¼šå‚ä¸è‡ªåŠ¨åˆæˆï¼Œ1 çº§æ°¸è¿œä¸ä¼šå‚ä¸
  function checkAutoMerge(changedIdx = null, allowEmptyMerge = true) {
    if (!allowEmptyMerge && grid.every(t => !t.crop)) {
      updateMainQuestProgress();
      return;
    }

    let merged;
    do {
      merged = false;

      // â­ å›ºå®šä» Level=2 å¼€å§‹æ£€æŸ¥ï¼ŒLv1 ä¸ä¼šè¢«ç”¨äºè‡ªåŠ¨åˆæˆ
      for (let level = 2; level < MAX_LAND_LEVEL; level++) {
        const indices = [];
        grid.forEach((t, i) => {
          if (!t.locked && t.landLevel === level) indices.push(i);
        });

        // åªæ‹¿â€œæ²¡æœ‰ä½œç‰©â€çš„åœ°å—ä½œä¸ºåˆæˆå¯¹è±¡
        const available = indices.filter(i => !grid[i].crop);
        if (available.length >= 3) {
          const target = (changedIdx !== null && available.includes(changedIdx))
            ? changedIdx
            : available[0];
          const others = available.filter(i => i !== target).slice(0, 2);

          // ç›®æ ‡åœ°å—å‡çº§
          updateTileLevel(grid[target], Math.min(MAX_LAND_LEVEL, level + 1));
          grid[target].crop = null;
          grid[target].ready = false;
          grid[target].plantedAt = 0;

          // å…¶ä½™ä¸¤å—æ¢å¤ä¸º Lv1ï¼ˆåŸºç¡€ç”°ï¼‰ï¼Œä½† Lv1 ä¸ä¼šå†å‚ä¸ä»»ä½•è‡ªåŠ¨åˆæˆ
          others.forEach(i => {
            updateTileLevel(grid[i], 1);
            grid[i].crop = null;
            grid[i].ready = false;
            grid[i].plantedAt = 0;
          });

          tip(`è‡ªåŠ¨åˆæˆï¼šLv${level} -> Lv${level + 1}`);
          changedIdx = target;
          merged = true;
          break;
        }
      }
    } while (merged);

    updateMainQuestProgress();
    renderUIQuick();
  }

  // ========= åŠ å·¥ä½æ‰©å±•é…ç½® =========
  const PROCESS_SLOT_MAX = 3;              // æœ€å¤š 3 ä¸ªåŠ å·¥ä½
  const PROCESS_SLOT_BASE_COST = 120;      // ç¬¬äºŒä¸ªåŠ å·¥ä½ä»·æ ¼
  const PROCESS_SLOT_COST_STEP = 80;       // åç»­æ¯ä¸ªåŠ å·¥ä½é€’å¢ä»·æ ¼

  function getNextProcessSlotCost() {
    // å½“å‰å·²ç»æœ‰ maxProcessingSlots ä¸ªï¼Œä¸‹ä¸€ä½çš„ä»·æ ¼åŸºäºæ­¤è®¡ç®—
    // ç¬¬ä¸€ä¸ªä½æ˜¯é»˜è®¤å…è´¹ï¼ˆmaxProcessingSlots ä» 1 èµ·ï¼‰
    if (maxProcessingSlots >= PROCESS_SLOT_MAX) return 0;
    return PROCESS_SLOT_BASE_COST + (maxProcessingSlots - 1) * PROCESS_SLOT_COST_STEP;
  }

  function buyProcessSlot() {
    if (maxProcessingSlots >= PROCESS_SLOT_MAX) {
      tip('åŠ å·¥ä½å·²ç»å…¨éƒ¨è§£é”ã€‚');
      showToast('åŠ å·¥ä½å·²ç»å…¨éƒ¨è§£é”ã€‚');
      return;
    }
    const cost = getNextProcessSlotCost();
    if (gold < cost) {
      tip('é‡‘å¸ä¸è¶³ï¼Œæ— æ³•è´­ä¹°æ–°çš„åŠ å·¥ä½ã€‚');
      showToast('é‡‘å¸ä¸è¶³ï¼Œæ— æ³•è´­ä¹°æ–°çš„åŠ å·¥ä½ã€‚');
      return;
    }
    gold -= cost;
    maxProcessingSlots += 1;
    tip('å·²è§£é”æ–°çš„åŠ å·¥ä½ï¼Œç°åœ¨å¯åŒæ—¶åŠ å·¥ ' + maxProcessingSlots + ' æ‰¹ã€‚');
    showToast('è§£é”åŠ å·¥ä½æˆåŠŸï¼å½“å‰åŠ å·¥ä½ï¼š' + maxProcessingSlots);
    renderUIQuick();
  }

  // ========= åŠ å·¥ =========
  function hasInput(input) { return Object.entries(input).every(([k,v]) => (storage.raw[k] || 0) >= v); }

  function startProcessing(recipeId) {
    const recipe = processingRecipes[recipeId];
    if (!recipe) {
      tip('æœªçŸ¥é…æ–¹ï¼Œæ— æ³•åŠ å·¥ã€‚');
      return;
    }

    if (processingSlots.length >= maxProcessingSlots) {
      tip('è½¦é—´åŠ å·¥ä½å·²æ»¡ï¼Œè¯·ç­‰å¾…å½“å‰åŠ å·¥å®Œæˆã€‚');
      showToast('åŠ å·¥ä½å·²æ»¡');
      return;
    }

    const level = getReputationLevel();
    if (level < recipe.unlockLevel) {
      tip('å£°æœ›ä¸è¶³ï¼Œæ— æ³•åˆ¶ä½œ');
      return;
    }
    if (!hasInput(recipe.input)) {
      tip('åŸæ–™ä¸è¶³');
      return;
    }

    Object.entries(recipe.input).forEach(function ([k, v]) {
      storage.raw[k] -= v;
    });

    processingSlots.push({
      recipeId: recipe.id,
      startedAt: gameTimeMinutes,
      timeTotal: recipe.timeMinutes
    });

    const hours = (recipe.timeMinutes / 60).toFixed(1);
    tip('å¼€å§‹åˆ¶ä½œ ' + recipe.name + 'ï¼Œé¢„è®¡ ' + hours + ' å°æ—¶å®Œæˆ');
    renderUIQuick();
  }

  // æ£€æŸ¥å½“å‰æ˜¯å¦æœ‰è®¢å•éœ€è¦æŸä¸ªæˆå“ï¼Œå¹¶ç»™å‡ºæç¤º
  function hintOrderForGoods(goodsId) {
    if (!activeOrders || !activeOrders.length) return;

    const hasOrder = activeOrders.some(function (o) {
      return (
        o.status === 'pending' &&
        o.require &&
        o.require[goodsId] &&
        o.require[goodsId] > 0
      );
    });

    if (!hasOrder) return;

    const msg =
      'æœ‰è®¢å•æ­£å¥½éœ€è¦ ' + goodsName(goodsId) + 'ï¼Œå¯ä»¥å»ã€Œè®¢å•ã€é¢æ¿çœ‹çœ‹ã€‚';
    tip(msg);
    showToast(msg);
  }

  function updateProcessing(deltaMinutes) {
    if (!processingSlots.length) return;

    const finishedIndexes = [];

    processingSlots.forEach(function (slot, index) {
      if (!slot) return;
      if (gameTimeMinutes - slot.startedAt < slot.timeTotal) return;

      const recipe = processingRecipes[slot.recipeId];
      if (!recipe) {
        finishedIndexes.push(index);
        return;
      }

      // è®°å½•æœ¬æ¬¡äº§å‡ºçš„æˆå“ IDï¼ˆç”¨äºåç»­è®¢å•æç¤ºï¼‰
      const producedGoods = [];

      Object.entries(recipe.output).forEach(function ([k, v]) {
        storage.goods[k] = (storage.goods[k] || 0) + v;
        producedGoods.push(k);
      });

      tip('åŠ å·¥å®Œæˆï¼š' + recipe.name);
      showToast('åŠ å·¥å®Œæˆï¼š' + recipe.name);

      if (recipe.id === 'pumpkin_pie') {
        achievementsState.highRecipe = true;
        updateAchievements();
      }
      if (recipe.id === 'bread') {
        updateMainQuestProgress('bread');
      }

      producedGoods.forEach(function (gid) { hintOrderForGoods(gid); });

      finishedIndexes.push(index);
    });

    // ä»åå¾€å‰åˆ é™¤å·²å®Œæˆçš„åŠ å·¥ä½ï¼Œé¿å… index æ··ä¹±
    finishedIndexes
      .sort(function (a, b) { return b - a; })
      .forEach(function (i) {
        processingSlots.splice(i, 1);
      });
  }

  // ========= å¸‚åœº =========
  function refreshMarketPrices(day) {
    marketPriceModifier = { ...MARKET_PRICE_TEMPLATE, ...marketPriceModifier };
    Object.keys(marketPriceModifier).forEach(key => {
      marketPriceModifier[key] = Number((0.9 + Math.random() * 0.3).toFixed(2));
    });
    renderMarket();
  }

  function sellItem(kind, id) {
    const store = kind === 'raw' ? storage.raw : storage.goods;
    const name = kind === 'raw' ? rawName(id) : goodsName(id);
    const count = store[id] || 0;
    if (count <= 0) { tip('æ²¡æœ‰å¯å‡ºå”®çš„åº“å­˜ã€‚'); showToast('æ²¡æœ‰å¯å‡ºå”®çš„åº“å­˜ã€‚'); return; }
    const unitPrice = getMarketPrice(kind, id);
    const gain = unitPrice * count;
    store[id] = 0;
    gold += gain;
    tip(`å‡ºå”®${name} ${count} ${kind === 'goods' ? 'ä»½' : 'ä¸ª'}ï¼Œè·å¾— ${gain} é‡‘å¸ã€‚`);
    showToast(`å‡ºå”®${name} ${count} ${kind === 'goods' ? 'ä»½' : 'ä¸ª'}ï¼Œè·å¾— ${gain} é‡‘å¸ã€‚`);
    renderUIQuick();
  }

  // ========= è®¢å• =========
  function rawName(id) {
    return {
      wheat: 'å°éº¦',
      corn: 'ç‰ç±³',
      pumpkin: 'å—ç“œ',
      radish: 'èåœ',       // new
      strawberry: 'è‰è“'    // new
    }[id] || id;
  }
  function goodsName(id) {
    return {
      bread: 'é¢åŒ…',
      popcorn: 'çˆ†ç±³èŠ±',
      pumpkin_pie: 'å—ç“œæ´¾',
      radish_pickles: 'è…Œèåœ', // new
      berry_jam: 'è‰è“é…±'       // new
    }[id] || id;
  }
  function getMarketPrice(kind, id) {
    const map = kind === 'raw' ? RAW_SELL_PRICES : GOODS_SELL_PRICES;
    const base = map[id] || 0;
    const modifier = marketPriceModifier[id] != null ? marketPriceModifier[id] : 1;

    // season: æ ¹æ®å­£èŠ‚è°ƒæ•´ä»·æ ¼
    const season = getCurrentSeason();
    let seasonFactor = 1;
    if (season) {
      if (kind === 'raw') {
        seasonFactor = season.priceFactorRaw || 1;
      } else {
        seasonFactor = season.priceFactorGoods || 1;
      }
    }

    return Math.max(1, Math.round(base * modifier * seasonFactor));
  }
  function canDeliver(order) { return Object.entries(order.require).every(([k,v]) => (storage.goods[k] || 0) >= v); }

  function deliverOrder(orderId) {
    const order = activeOrders.find(o => o.id === orderId && o.status === 'pending');
    if (!order) { tip('è®¢å•ä¸å­˜åœ¨'); return; }
    if (!canDeliver(order)) { tip('æˆå“ä¸è¶³ï¼Œæ— æ³•äº¤ä»˜'); return; }
    Object.entries(order.require).forEach(([k,v]) => storage.goods[k] -= v);
    gold += order.reward.gold;
    addReputation(order.reward.reputation);
    if (order.reward.seeds) inventory[order.reward.seeds] = (inventory[order.reward.seeds]||0) + 1;
    order.status = 'completed';
    achievementsState.ordersDone += 1;
    updateAchievements();
    if (dailyQuestState && !dailyQuestState.completed && dailyQuestState.type === 'orders') {
      dailyQuestState.progress = Math.min(dailyQuestState.target, dailyQuestState.progress + 1);
      checkDailyQuestCompletion();
    }
    updateMainQuestProgress('order');
    tip('è®¢å•å·²å®Œæˆï¼Œè·å¾—å¥–åŠ±');
    showToast('è®¢å•äº¤ä»˜æˆåŠŸ');
    renderUIQuick();
  }

  function generateDailyQuest(day) {
    const type = Math.random() < 0.5 ? 'harvest' : 'orders';
    let target;
    let rewardGold;
    if (type === 'harvest') {
      target = Math.min(10, randInt(3,7) + Math.floor(day/6));
      rewardGold = Math.min(80, Math.max(40, 35 + target * 7));
    } else {
      target = Math.min(5, randInt(1,3) + Math.floor(day/8));
      rewardGold = Math.min(80, Math.max(40, 45 + target * 12));
    }
    return { day, type, target, progress: 0, reward: { gold: rewardGold, reputation: 1 }, completed: false };
  }

  function checkDailyQuestCompletion() {
    if (dailyQuestState && !dailyQuestState.completed && dailyQuestState.progress >= dailyQuestState.target) {
      dailyQuestState.completed = true;
      gold += dailyQuestState.reward.gold;
      addReputation(dailyQuestState.reward.reputation);
      const rewardMsg = `ä»Šæ—¥ä»»åŠ¡å®Œæˆï¼è·å¾—é‡‘å¸ ${dailyQuestState.reward.gold}ï¼Œå£°æœ› ${dailyQuestState.reward.reputation}`;
      tip(rewardMsg);
      showToast(rewardMsg);
    }
    renderDailyQuest();
  }

  function updateMainQuestProgress(trigger = '') {
    if (mainQuestState.completed) return;
    if (mainQuestState.step === 0) {
      const hasHighLand = grid.some(t => !t.locked && t.landLevel >= 3);
      if (hasHighLand) { mainQuestState.step = 1; renderMainQuest(); }
    }
    if (mainQuestState.step === 1 && trigger === 'bread') {
      mainQuestState.step = 2;
      renderMainQuest();
    }
    if (mainQuestState.step === 2 && achievementsState.ordersDone >= 3) {
      mainQuestState.completed = true;
      renderMainQuest();
    }
  }

  function onNewGameDay(day) {
    activeOrders.forEach(o => { if (o.status === 'pending' && day > o.deadlineDay) o.status = 'expired'; });
    const maxOrders = MAX_ORDERS_BASE + getReputationLevel();
    const pending = activeOrders.filter(o => o.status === 'pending');
    const need = Math.max(0, maxOrders - pending.length);
    for (let i=0; i<need; i++) { activeOrders.push(generateRandomOrder(day)); }
    dailyQuestState = generateDailyQuest(day);
    renderDailyQuest();
    refreshMarketPrices(day);
    tip(`æ–°çš„ä¸€å¤©ï¼ˆç¬¬${day}å¤©ï¼‰ï¼Œåˆ·æ–°äº† ${need} å¼ è®¢å•ï¼Œå¸‚åœºè¡Œæƒ…å·²æ›´æ–°`);

    // season: æ›´æ–°å­£èŠ‚ï¼Œå¹¶åœ¨å­£èŠ‚å˜åŒ–æ—¶æç¤º
    const beforeIndex = currentSeasonIndex;
    updateSeasonByGameTime();
    if (currentSeasonIndex !== beforeIndex) {
      const s = getCurrentSeason();
      if (s) {
        tip("å­£èŠ‚å˜åŒ–ï¼šè¿›å…¥" + s.name + "ã€‚" + s.desc);
        showToast("å­£èŠ‚å˜åŒ–ï¼š" + s.name);
      }
    }
    renderSeasonCard();
  }

  function generateRandomOrder(day) {
    const goodsPool = ['bread', 'popcorn', 'radish_pickles']; // new
    const repLevel = getReputationLevel();
    if (repLevel >= 1) goodsPool.push('berry_jam');          // new
    if (repLevel >= 2) goodsPool.push('pumpkin_pie');
    const gid = goodsPool[Math.floor(Math.random()*goodsPool.length)];
    const count = Math.max(1, Math.min(4, Math.floor(day/3)+1));
    const baseGold = goodsPrices[gid] || 25;
    const goldReward = baseGold * count + getReputationLevel()*3;
    const rep = 1 + (getReputationLevel() >=2 ? 1 : 0);
    const seedReward = Math.random() < 0.25 ? 'basic_wheat' : null;
    return {
      id: 'order_'+Date.now()+Math.random().toString(16).slice(2,6),
      title: 'æ‘æ°‘è®¢å•',
      description: `éœ€è¦ ${goodsName(gid)} x${count}`,
      require: { [gid]: count },
      reward: { gold: goldReward, reputation: rep, seeds: seedReward },
      deadlineDay: day + 2,
      status: 'pending'
    };
  }

  // ========= å£°æœ› =========


  // perk: æ ¹æ®å¤©èµ‹æ•ˆæœå åŠ åˆ°å…¨å±€ä¿®æ­£ç³»æ•°
  function applyPerk(perk) {
    if (!perk || !perk.effect) return;
    globalModifiers.yieldBonus += perk.effect.yieldBonus || 0;
  }

  // perk: ä» playerStats.perks é‡æ–°è®¡ç®— globalModifiersï¼ˆè¯»æ¡£/æ–°å»ºæ—¶ç”¨ï¼‰
  function recomputeGlobalModifiers() {
    globalModifiers = {
      yieldBonus: 0
    };
    const list = playerStats.perks || []; 
    list.forEach(id => {
      const perk = PERKS[id];
      if (perk) applyPerk(perk);
    });
  }

  // perk: ç»Ÿä¸€å…¥å£ï¼Œå¢åŠ å£°æœ›å¹¶æ£€æµ‹å‡çº§
  function addReputation(amount) {
    if (!amount) return;
    const prevLevel = getReputationLevel();
    playerStats.reputation = (playerStats.reputation || 0) + amount;
    if (playerStats.reputation < 0) playerStats.reputation = 0;
    const newLevel = getReputationLevel();

    if (newLevel > prevLevel) {
      handleReputationLevelUp(prevLevel, newLevel);
    }
  }

  // perk: å£°æœ›ç­‰çº§æå‡åï¼Œä¾æ¬¡å¤„ç†æ¯ä¸€çº§
  function handleReputationLevelUp(prevLevel, newLevel) {
    for (let lvl = prevLevel + 1; lvl <= newLevel; lvl++) {
      offerPerkChoiceForLevel(lvl);
    }
  }

  // perk: å½“å‰ç‰ˆæœ¬åªåœ¨ 1 çº§æ—¶æä¾›â€œä¸°æ”¶ç”°â€å¤©èµ‹
  function offerPerkChoiceForLevel(level) {
    playerStats.perks = playerStats.perks || [];

    // è§„åˆ™ï¼šä» 0â†’1 çº§ä¸”å°šæ— å¤©èµ‹æ—¶èµ é€
    if (level === 1 && playerStats.perks.length === 0) {
      const perk = PERKS.moreYield; 
      if (perk && !playerStats.perks.includes(perk.id)) {
        playerStats.perks.push(perk.id);
        applyPerk(perk);
        tip('å£°æœ›è¾¾åˆ° 1 çº§ï¼Œè·å¾—å¤©èµ‹ã€' + perk.name + 'ã€‘');
        showToast('è·å¾—å¤©èµ‹ã€' + perk.name + 'ã€‘');
      }
    }

    // é¢„ç•™ï¼šä»¥åå¯ä»¥åœ¨æ›´é«˜ç­‰çº§å¢åŠ æ›´å¤šå¤©èµ‹é€‰æ‹©é€»è¾‘
  }

  function getReputationLevel() {
    const rep = playerStats.reputation || 0;
    if (rep >= 15) return 3;
    if (rep >= 7) return 2;
    if (rep >= 3) return 1;
    return 0;
  }

  // ========= æ¸¸æˆå¾ªç¯ =========
  function gameLoop() {
    const now = Date.now();
    const delta = now - lastTick;
    lastTick = now;
    const deltaMinutes = (delta / 1000) * TIME_SPEED;
    gameTimeMinutes += deltaMinutes;
    updateFarmCrops();
    updateProcessing(deltaMinutes);
    updateUI();
  }

  function updateFarmCrops() {
    grid.forEach(tile => {
      if (tile.crop && !tile.ready) {
        const elapsed = gameTimeMinutes - tile.plantedAt;
        if (elapsed >= tile.growTime) { tile.ready = true; }
      }
    });
    const readyCount = grid.filter(t => t.ready).length;
    if (readyCount !== lastReadyCount) {
      lastReadyCount = readyCount;
      if (readyCount > 0) {
        tip(`å·²æœ‰ ${readyCount} å—åœŸåœ°çš„ä½œç‰©æˆç†Ÿäº†ï¼Œç‚¹å‡»å¯¹åº”åœ°å—å³å¯æ”¶è·ã€‚`);
      }
    }
  }

  function animationLoop() {
    renderCanvas();
    requestAnimationFrame(animationLoop);
  }

  // ========= å­˜æ¡£ / è¯»æ¡£ =========
  function saveGame() {
    const account = getCurrentAccount();
    if (!account) { tip('è¯·å…ˆè¾“å…¥è´¦å·å'); return; }
    const data = {
      gold,
      gameTimeMinutes,
      grid,
      inventory,
      storage,
      processingSlots,
      maxProcessingSlots,
      activeOrders,
      lastGameDay,
      playerStats,
      globalModifiers,
      achievementsState,
      dailyQuestState,
      mainQuestState,
      selectedSeed,
      mode,
      marketPriceModifier
    };
    localStorage.setItem('farm_save_'+account, JSON.stringify(data));
    tip('å·²ä¿å­˜');
    showToast('å­˜æ¡£æˆåŠŸ');
    addAccountIfNotExists(account);
  }

  function normalizeGridAfterLoad() {
    const typeToLevel = {}; Object.entries(LAND_LEVEL_CONFIG).forEach(([lvl, cfg]) => { typeToLevel[cfg.type] = Number(lvl); });
    grid = (grid || []).map(t => {
      const tile = createTile(true, 1);
      Object.assign(tile, t);
      if (tile.skin === undefined) tile.skin = null;
      if (tile.locked === undefined) tile.locked = false;
      const level = tile.landLevel || typeToLevel[tile.land] || 1;
      updateTileLevel(tile, level);
      return tile;
    });
    while (grid.length < GRID_SIZE * GRID_SIZE) grid.push(createTile(true, 1));
    grid = grid.slice(0, GRID_SIZE * GRID_SIZE);
  }

  function loadGame() {
    const account = getCurrentAccount();
    if (!account) { tip('è¯·å…ˆè¾“å…¥è´¦å·å'); return; }
    const raw = localStorage.getItem('farm_save_'+account);
    if (!raw) { tip('æœªæ‰¾åˆ°å­˜æ¡£'); return; }
    try {
      const data = JSON.parse(raw);
      gold = data.gold ?? gold;
      gameTimeMinutes = data.gameTimeMinutes ?? 0;
      updateSeasonByGameTime();
      renderSeasonCard();
      grid = data.grid ?? grid;
      normalizeGridAfterLoad();
      inventory = data.inventory ?? inventory;
      inventory.fast_radish = inventory.fast_radish || 0; // new seed default
      inventory.berry = inventory.berry || 0;             // new seed default
      storage = data.storage ?? storage;
      storage.raw = {
        wheat: 0,
        corn: 0,
        pumpkin: 0,
        radish: 0,      // new raw
        strawberry: 0,  // new raw
        ...(storage.raw || {})
      };
      storage.goods = {
        bread: 0,
        popcorn: 0,
        pumpkin_pie: 0,
        radish_pickles: 0, // new product
        berry_jam: 0,      // new product
        ...(storage.goods || {})
      };
      marketPriceModifier = { ...MARKET_PRICE_TEMPLATE, ...(data.marketPriceModifier || {}) };
      if (!data.marketPriceModifier) refreshMarketPrices(Math.floor(gameTimeMinutes / DAY_MINUTES) + 1);
      processingSlots = data.processingSlots ?? [];
      maxProcessingSlots = data.maxProcessingSlots ?? 1;

      // å‘ä¸‹å…¼å®¹æ—§å­˜æ¡£ï¼šæ—§ç‰ˆæœ¬åªæœ‰ processingSlot
      if (!processingSlots.length && data.processingSlot) {
        processingSlots = [data.processingSlot];
        if (!maxProcessingSlots || maxProcessingSlots < 1) {
          maxProcessingSlots = 1;
        }
      }

      activeOrders = data.activeOrders ?? [];
      lastGameDay = data.lastGameDay ?? 1;
      playerStats = data.playerStats ?? playerStats;
      if (!playerStats.perks) playerStats.perks = [];
      globalModifiers = data.globalModifiers ?? globalModifiers;
      recomputeGlobalModifiers();
    achievementsState = data.achievementsState ?? achievementsState;
    if (!achievementsState.claimed) achievementsState.claimed = {};
      dailyQuestState = data.dailyQuestState ?? dailyQuestState;
      mainQuestState = data.mainQuestState ?? mainQuestState;
      if (!dailyQuestState) dailyQuestState = generateDailyQuest(Math.floor(gameTimeMinutes / DAY_MINUTES) + 1);
      if (!mainQuestState || mainQuestState.step === undefined) mainQuestState = { step: 0, completed: false };
      selectedSeed = data.selectedSeed ?? '';
      mode = data.mode ?? 'normal';
      if (mode !== 'normal' && mode !== 'swap') mode = 'normal';
      tip('å­˜æ¡£å·²åŠ è½½');
      renderSeedSelect();
      setMode(mode);
      updateMainQuestProgress();
      updateAchievements();
      renderDailyQuest();
      renderMainQuest();
      renderUIQuick();
    } catch (e) {
      tip('å­˜æ¡£è¯»å–å¤±è´¥');
      console.error(e);
    }
  }

  function getCurrentAccount() {
    const input = document.getElementById('accountName');
    const name = input.value.trim();
    const sel = document.getElementById('accountSelect');
    return name || sel.value || '';
  }

  function createAccount() {
    const name = document.getElementById('accountName').value.trim();
    if (!name) { tip('è¯·è¾“å…¥è´¦å·å'); return; }
    addAccountIfNotExists(name);
    document.getElementById('accountSelect').value = name;
    tip('å·²åˆ‡æ¢/åˆ›å»ºè´¦å·ï¼š'+name);
    initGrid();
      gold = 300;
      gameTimeMinutes = 0;
      updateSeasonByGameTime();
      renderSeasonCard();
      inventory = {
        basic_wheat: 2,
        mid_corn: 0,
        high_pumpkin: 0,
        fast_radish: 0, // new seed
        berry: 0        // new seed
      };
      storage = {
        raw: {
          wheat: 0,
          corn: 0,
          pumpkin: 0,
          radish: 0,      // new raw
          strawberry: 0   // new raw
        },
        goods: {
          bread: 0,
          popcorn: 0,
          pumpkin_pie: 0,
          radish_pickles: 0, // new product
          berry_jam: 0       // new product
        }
      };
      marketPriceModifier = { ...MARKET_PRICE_TEMPLATE };
      processingSlots = [];
      maxProcessingSlots = 1;
      activeOrders = [];
      lastGameDay = 1;
      playerStats = { reputation: 0, perks: [] };
      // perk: é‡ç½®å¤©èµ‹åŠ æˆ
      globalModifiers = { yieldBonus: 0 };
      recomputeGlobalModifiers();
    achievementsState = { harvestCount: 0, ordersDone: 0, highRecipe: false, claimed: {} };
    dailyQuestState = generateDailyQuest(1);
    mainQuestState = { step: 0, completed: false };
    selectedSeed = '';
    mode = 'normal'; swapSelection = []; selectedTile = -1; setMode('normal');
    refreshMarketPrices(1);
    updateAchievements();
    renderDailyQuest();
    renderMainQuest();
    renderUIQuick();
  }

  function deleteAccount() {
    const name = getCurrentAccount();
    if (!name) { tip('è¯·é€‰æ‹©è´¦å·'); return; }
    localStorage.removeItem('farm_save_'+name);
    removeAccountFromList(name);
    tip('å·²åˆ é™¤è´¦å· '+name);
  }

  function loadAccountsToSelect() {
    const sel = document.getElementById('accountSelect');
    const list = JSON.parse(localStorage.getItem('farm_accounts') || '[]');
    sel.innerHTML = '';
    list.forEach(n => { const opt = document.createElement('option'); opt.value = n; opt.textContent = n; sel.appendChild(opt); });
    if (list[0]) sel.value = list[0];
  }

  function addAccountIfNotExists(name) {
    const list = JSON.parse(localStorage.getItem('farm_accounts') || '[]');
    if (!list.includes(name)) { list.push(name); localStorage.setItem('farm_accounts', JSON.stringify(list)); loadAccountsToSelect(); }
  }

  function removeAccountFromList(name) {
    const list = JSON.parse(localStorage.getItem('farm_accounts') || '[]').filter(n => n !== name);
    localStorage.setItem('farm_accounts', JSON.stringify(list));
    loadAccountsToSelect();
  }

  // åˆå§‹åŒ–ä¸€ä¸ªæµ‹è¯•è´¦å·ï¼Œé‡‘å¸ 10000ï¼Œå…¶ä½™èµ„æº 100
  function ensureTestAccount() {
    const testName = 'test';
    const saveKey = 'farm_save_' + testName;
    const accounts = JSON.parse(localStorage.getItem('farm_accounts') || '[]');
    if (!accounts.includes(testName)) {
      accounts.push(testName);
      localStorage.setItem('farm_accounts', JSON.stringify(accounts));
    }

    if (!localStorage.getItem(saveKey)) {
      const makeGrid = () => {
        const arr = new Array(GRID_SIZE * GRID_SIZE).fill(0).map(() => createTile(true, 1));
        for (let i = 0; i < 3; i++) {
          arr[i].locked = false;
          updateTileLevel(arr[i], 1);
        }
        return arr;
      };

        const data = {
          gold: 10000,
          gameTimeMinutes: 0,
          grid: makeGrid(),
          inventory: {
            basic_wheat: 100,
            mid_corn: 100,
            high_pumpkin: 100,
            fast_radish: 100, // new seed
            berry: 100        // new seed
          },
          storage: {
            raw: {
              wheat: 100,
              corn: 100,
              pumpkin: 100,
              radish: 100,      // new raw
              strawberry: 100   // new raw
            },
            goods: {
              bread: 100,
              popcorn: 100,
              pumpkin_pie: 100,
              radish_pickles: 100, // new product
              berry_jam: 100       // new product
            }
          },
          processingSlots: [],
          maxProcessingSlots: 1,
          activeOrders: [],
          lastGameDay: 1,
          playerStats: { reputation: 0, perks: [] },
          achievementsState: { harvestCount: 0, ordersDone: 0, highRecipe: false, claimed: {} },
          dailyQuestState: generateDailyQuest(1),
        mainQuestState: { step: 0, completed: false },
        selectedSeed: '',
        mode: 'normal',
        marketPriceModifier: { ...MARKET_PRICE_TEMPLATE },
        globalModifiers: { yieldBonus: 0 } // perk: ???????????
      };
      localStorage.setItem(saveKey, JSON.stringify(data));
    }
  }

  // ========= å·¥å…· =========
  // season: æ ¹æ®å½“å‰æ¸¸æˆå¤©æ•°æ›´æ–°å­£èŠ‚ç´¢å¼•
  function updateSeasonByGameTime() {
    const day = Math.floor(gameTimeMinutes / DAY_MINUTES) + 1;
    const idx = Math.floor((day - 1) / SEASON_LENGTH_DAYS) % SEASONS.length;
    currentSeasonIndex = idx;
  }

  // season: è·å–å½“å‰å­£èŠ‚é…ç½®
  function getCurrentSeason() {
    return SEASONS[currentSeasonIndex] || SEASONS[0];
  }

  function tip(msg) { tipMessage = msg; }
  function renderUIQuick() { updateUI(); }
  function showToast(msg) { const el = document.getElementById('toast'); el.textContent = msg; el.classList.add('show'); setTimeout(() => el.classList.remove('show'), 2000); }
  function randInt(a,b) { return Math.floor(Math.random()*(b-a+1))+a; }
  // season: è®¡ç®—æŸå—åœ°ä¸ŠæŸç§ä½œç‰©çš„ç”Ÿé•¿æ—¶é—´ï¼ˆè€ƒè™‘å­£èŠ‚å’Œåœ°å—è‚¥åŠ›ï¼‰
  function calcGrowTimeForTile(cfg, tile) {
    if (!cfg || !tile) return 0;
    const season = getCurrentSeason();
    const growFactor = season && typeof season.growFactor === 'number' ? season.growFactor : 1;
    const fertility = tile.fertility || 1;
    const base = cfg.growTime;
    return Math.round(base * growFactor / fertility);
  }
  function updateFarmStats() {
    const planted = grid.filter(t => !t.locked && t.crop).length;
    const unlocked = grid.filter(t => !t.locked).length;
    const ready = grid.filter(t => !t.locked && t.ready).length;
    const avgFert = unlocked ? (grid.filter(t => !t.locked).reduce((sum, t) => sum + (t.fertility || 1), 0) / unlocked) : 1;
    const bonus = Math.max(0, Math.round((avgFert - 1) * 100));
    const plantedEl = document.getElementById('farmStatPlanted');
    const readyEl = document.getElementById('farmStatReady');
    const bonusEl = document.getElementById('farmStatBonus');
    if (plantedEl) plantedEl.textContent = `${planted} / ${unlocked}`;
    if (readyEl) readyEl.textContent = `${ready} å—`;
    if (bonusEl) bonusEl.textContent = `+${bonus}%`;
  }

  // ========= æ”¶è·å³æ—¶å†³ç­–é¢æ¿ =========

  function openHarvestDecisionPanel(info) {
    pendingHarvestDecision = info;
    const panel = document.getElementById('harvestDecision');
    const textEl = document.getElementById('harvestDecisionText');

    if (!panel || !textEl) return;

    // å±•ç¤ºç®€å•è¯´æ˜ï¼šä½œç‰©å + æ•°é‡
    textEl.textContent =
      'æ”¶è· ' + info.cropName + 'ï¼šå…± ' + info.yieldCount + ' ä¸ªã€‚è¯·é€‰æ‹©å¤„ç†æ–¹å¼ï¼š';

    panel.classList.remove('hidden');
  }

  function closeHarvestDecisionPanel() {
    const panel = document.getElementById('harvestDecision');
    if (panel) {
      panel.classList.add('hidden');
    }
    pendingHarvestDecision = null;
  }

  // action: 'sell' | 'store'
  function confirmHarvestDecision(action) {
    if (!pendingHarvestDecision) {
      closeHarvestDecisionPanel();
      return;
    }

    const info = pendingHarvestDecision;
    const tile = grid[info.tileIndex];
    const cfg = seeds[info.seedId] || { name: info.cropName || 'ä½œç‰©' };

    if (!tile || !tile.crop || !tile.ready) {
      // åœ°å—çŠ¶æ€ä¸å¯¹ï¼Œç›´æ¥å…³é—­
      closeHarvestDecisionPanel();
      return;
    }

    if (action === 'sell') {
      // ç›´æ¥å–æ‰ï¼šåªç»™é‡‘å¸ï¼Œä¸è¿›ä»“
      gold += info.baseGold;
      spawnFloatingTextForTile(info.tileIndex, '+' + info.baseGold + ' é‡‘å¸', '#ffd54f');
      tip('æ”¶è· ' + cfg.name + ' å¹¶ç›´æ¥å‡ºå”®ï¼Œè·å¾— ' + info.baseGold + ' é‡‘å¸ã€‚');
    } else {
      // å…¥ä»“åŠ å·¥ï¼šåªè¿›ä»“ï¼Œä¸ç»™è¿™ç¬”å³æ—¶é‡‘å¸
      if (info.rawId) {
        storage.raw[info.rawId] = (storage.raw[info.rawId] || 0) + info.yieldCount;
        spawnFloatingTextForTile(
          info.tileIndex,
          '+' + info.yieldCount + ' åŸæ–™',
          '#a5d6a7'
        );
      }
      tip('æ”¶è· ' + cfg.name + 'ï¼ŒåŸæ–™ +' + info.yieldCount + 'ï¼Œç­‰å¾…åç»­åŠ å·¥ã€‚');
    }

    // é€šç”¨çš„æ”¶è·ç»Ÿè®¡å’Œä»»åŠ¡è¿›åº¦
    achievementsState.harvestCount += 1;
    updateAchievements();

    if (dailyQuestState && !dailyQuestState.completed && dailyQuestState.type === 'harvest') {
      dailyQuestState.progress = Math.min(
        dailyQuestState.target,
        dailyQuestState.progress + 1
      );
      checkDailyQuestCompletion();
    }

    // æ¸…ç©ºåœ°å—ä½œç‰©
    tile.crop = null;
    tile.ready = false;

    // æ”¶è·åè§¦å‘è‡ªåŠ¨åˆæˆé€»è¾‘ï¼ˆæŒ‰ä½ ç°åœ¨çš„è§„åˆ™ï¼šåªåˆæˆ Lv2+ï¼‰
    checkAutoMerge(info.tileIndex, false);

    closeHarvestDecisionPanel();
    renderUIQuick();
  }

  // ========= å³ä¾§æ ‡ç­¾åˆå§‹åŒ– =========
  function initRightTabs() {
    const buttons = document.querySelectorAll('.right-tabs-header .tab-btn');
    const panels = document.querySelectorAll('.sidebar.right .tab-panel');
    if (!buttons.length || !panels.length) return;
    buttons.forEach(btn => {
      btn.addEventListener('click', () => {
        const tab = btn.dataset.tab;
        setRightTab(tab);
      });
    });
  }

  function setRightTab(tabName) {
    const buttons = document.querySelectorAll('.right-tabs-header .tab-btn');
    const panels = document.querySelectorAll('.sidebar.right .tab-panel');
    if (!buttons.length || !panels.length) return;
    buttons.forEach(btn => {
      btn.classList.toggle('active', btn.dataset.tab === tabName);
    });
    panels.forEach(p => {
      p.classList.toggle('active', p.dataset.tab === tabName);
    });
  }

  function openMarketShortcut() {
    setRightTab('market');
  }

  function openAchievementShortcut() {
    setRightTab('achievement');
  }

  // ========= å¿«æ·æ“ä½œ =========
  function handleQuickHarvest() {
    const readyList = [];
    grid.forEach((tile, idx) => { if (!tile.locked && tile.crop && tile.ready) readyList.push(idx); });
    if (!readyList.length) { tip('æš‚æ— æˆç†Ÿä½œç‰©å¯æ”¶è·'); showToast('æš‚æ— æˆç†Ÿä½œç‰©å¯æ”¶è·'); return; }
    let totalGold = 0;
    let totalCount = 0;
    readyList.forEach(idx => {
      const tile = grid[idx];
      if (!tile.crop) return;
      const cfg = seeds[tile.crop.seedId];
      if (!cfg) { tile.crop = null; tile.ready = false; return; }
      let yieldCount = randInt(cfg.yield[0], cfg.yield[1]);

      // perk: ä¸°æ”¶ç”°å¤©èµ‹ï¼Œå¢åŠ äº§é‡
      if (globalModifiers.yieldBonus > 0) {
        yieldCount = Math.max(1, Math.round(yieldCount * (1 + globalModifiers.yieldBonus)));
      }
      const rawId = harvestRawMap[cfg.id];
      if (rawId) storage.raw[rawId] = (storage.raw[rawId] || 0) + yieldCount;
      const baseGold = Math.round(cfg.basePrice * 0.5 * yieldCount);
      gold += baseGold;
      totalGold += baseGold;
      achievementsState.harvestCount += 1;
      if (dailyQuestState && !dailyQuestState.completed && dailyQuestState.type === 'harvest') {
        dailyQuestState.progress = Math.min(dailyQuestState.target, dailyQuestState.progress + 1);
      }
      tile.crop = null;
      tile.ready = false;
      totalCount += 1;
    });
    updateAchievements();
    checkDailyQuestCompletion();
    lastReadyCount = grid.filter(t => t.ready).length;
    tip(`å·²æ”¶è· ${totalCount} å—åœ°ï¼Œè·å¾— ${totalGold} é‡‘å¸ã€‚`);
    showToast(`ä¸€é”®æ”¶è·å®Œæˆï¼š+${totalGold} é‡‘å¸`);
    spawnFloatingTextAt(canvas.width / 2 - 40, canvas.height / 2, `+${totalGold} é‡‘å¸`, '#ffe082');
    checkAutoMerge();
  }

  function handleQuickPlant() {
    if (!selectedSeed) { tip('è¯·é€‰æ‹©ç§å­'); return; }
    const cfg = seeds[selectedSeed];
    if (!cfg) { tip('è¯·é€‰æ‹©æœ‰æ•ˆç§å­'); return; }
    const seedCount = inventory[selectedSeed] || 0;
    if (seedCount <= 0) { tip('ç§å­ä¸è¶³ï¼Œå»å•†åº—è¡¥è´§'); showToast('ç§å­ä¸è¶³ï¼Œå»å•†åº—è¡¥è´§'); return; }
    const emptyTiles = [];
    grid.forEach((tile, idx) => { if (!tile.locked && !tile.crop) emptyTiles.push(idx); });
    if (!emptyTiles.length) { tip('æ²¡æœ‰ç©ºåœ°å¯ä»¥æ’­ç§'); return; }
    let planted = 0;
    for (const idx of emptyTiles) {
      if ((inventory[selectedSeed] || 0) <= 0) break;
      const tile = grid[idx];
      tile.crop = { seedId: selectedSeed };
      tile.plantedAt = gameTimeMinutes;
      tile.growTime = calcGrowTimeForTile(cfg, tile); // season: ä½¿ç”¨å­£èŠ‚å…¬å¼
      tile.ready = false;
      inventory[selectedSeed] -= 1;
      planted += 1;
    }
    if (planted === 0) { tip('ç§å­ä¸è¶³ï¼Œå»å•†åº—è¡¥è´§'); return; }
    tip(`å·²åœ¨ ${planted} å—åœ°æ’­ç§ ${cfg.name}`);
    showToast(`æ’­ç§å®Œæˆï¼š${planted} å—åœ°`);
    renderUIQuick();
  }

  function handleQuickFertilize() {
    const targets = [];
    grid.forEach(tile => { if (!tile.locked && tile.crop) targets.push(tile); });
    if (!targets.length) { tip('æ²¡æœ‰å¯æ–½è‚¥çš„åœ°å—'); return; }
    targets.forEach(tile => {
      tile.growTime = Math.max(30, Math.round(tile.growTime * 0.9));
    });
    tip(`å·²ä¸º ${targets.length} å—åœ°æ–½è‚¥ï¼Œç”Ÿé•¿æ—¶é—´ç¼©çŸ­ 10%`);
    showToast(`æ–½è‚¥å®Œæˆï¼š${targets.length} å—åœ°`);
    renderUIQuick();
  }

  function handleToggleDisplayMode() {
    const next = mode === 'normal' ? 'swap' : 'normal';
    setMode(next);
    showToast(`å·²åˆ‡æ¢åˆ°${next === 'normal' ? 'æ­£å¸¸' : 'äº¤æ¢'}æ¨¡å¼`);
  }

  // ========= å¯åŠ¨ =========
  init();
</script>
</body>
</html>
